# Gong 协调系统设计笔记

## 背景

在用 Claude Code 的 TaskList 跟踪 Gong 项目开发进度时，发现了一个通用模式：

1. **创建任务**（TaskCreate）→ 得到唯一 ID
2. **声明依赖**（TaskUpdate + addBlockedBy）→ 构建 DAG
3. **找可做的**（TaskList → 过滤未被阻塞的 → 选 ID 最小的）
4. **执行并标记**（in_progress → completed）
5. **解除下游阻塞** → 循环

这个模式在三个层面都出现了：

| 系统 | 任务单元 | 依赖机制 | 调度方式 | 持久化 |
|------|----------|----------|----------|--------|
| Claude Code TaskList | Task | blockedBy | 手动判断 | 无（内存） |
| Beads/Gastown | Bead | `bd dep add` + 类型化依赖 | `bd ready` 自动算 | Git JSONL + SQLite |
| Jido.Plan | PlanInstruction | `depends_on` | 拓扑排序 + 并行阶段 | 无（进程内） |

本质是同一个问题：**给定一组有依赖关系的工作单元，如何确定执行顺序并最大化并行度。**

---

## Jido 已有的协调能力

### 1. Jido.Plan — DAG 任务图

最接近 Beads 理念的模块。核心 API：

```elixir
plan = Plan.new()
|> Plan.add(:fetch, FetchAction)
|> Plan.add(:validate, ValidateAction, depends_on: :fetch)
|> Plan.add(:save, SaveAction, depends_on: :validate)
|> Plan.add(:notify, NotifyAction, depends_on: :fetch)
```

能力：
- 自动拓扑排序，检测循环依赖
- 计算并行执行阶段（同阶段内无依赖的 Action 并行跑）
- 结果在阶段间传递

局限：
- 进程内，无持久化
- 不支持运行中动态添加步骤
- 不支持跨 Agent 协作

### 2. Jido.Tools.Workflow — 工作流引擎

在 Plan 之上增加控制流：

```elixir
steps: [
  {:step, [name: "fetch"], [{FetchAction}]},
  {:branch, [name: "check"], [condition?, true_branch, false_branch]},
  {:parallel, [max_concurrency: 4], [action1, action2, action3]},
  {:converge, [name: "merge"], [{MergeAction}]}
]
```

能力：
- 顺序、并行、条件分支、汇聚
- max_concurrency 控制并行度
- 步骤失败中断整个工作流

### 3. OrchestratorAgent — 多 Agent 编排

LLM 驱动的动态路由：

```
用户请求 → Orchestrator（LLM 判断路由）→ 动态创建 Specialist Agent → 执行 → 聚合结果
```

能力：
- Specialist 按能力声明（name + description + tools）
- LLM 自动选择最合适的 Specialist
- Specialist 是临时的（spawn → work → dispose）

### 4. Jido.Signal.Bus — 事件总线

解耦的发布/订阅协调：

```elixir
Bus.subscribe(:bus, "order.*", dispatch: {:pid, target: self()})
Bus.publish(:bus, [signal])
```

能力：
- Trie 路径匹配（`order.*`、`order.**`）
- 多种分发方式（pid / pubsub / http / webhook）
- 确认机制、死信队列、回放

### 5. Jido.Thread — 执行日志

不可变的追加日志，类似 Beads 的 git 审计轨迹：

```elixir
thread = Thread.append(thread, [
  %{kind: :action, payload: %{name: "fetch", status: "completed"}}
])
```

---

## 缺失的部分：持久化协调

对比 Beads，Jido.Plan 缺的核心能力是：

### 1. 持久化

Jido.Plan 是纯内存数据结构。Agent 崩溃 = 进度丢失。
Beads 用 Git JSONL + SQLite 缓存，任何 Agent 可以接续。

**可能的方案**：Plan 状态序列化到 Gong.Tape.Store（已有的 JSONL 存储层），
崩溃恢复时从最后一个 checkpoint 重建。

### 2. 跨 Agent 协作

Jido.Plan 在单个 Agent 进程内执行。
Beads 的 `bd ready` 让多个 Agent 竞争性领取任务。

**可能的方案**：Signal.Bus 发布任务可用事件，Agent 订阅并竞争领取。
或者用 Jido 的 Directive.SpawnAgent 创建子 Agent，每个子 Agent 执行一个 Phase。

### 3. 动态步骤

Jido.Plan 在执行前必须定义完整 DAG。
Beads 支持运行中 `bd create` 新任务。

**可能的方案**：在 Workflow 的 step 执行中，允许返回新的 Plan 步骤
（类似 Gastown 的 "discovered-from" 依赖类型）。

### 4. 类型化依赖

Jido.Plan 只有 `depends_on`（硬阻塞）。
Beads 有 blocks / related / conditional-blocks / discovered-from。

**可能的方案**：扩展 PlanInstruction 的 depends_on 为
`{:blocks, :step_name}` | `{:soft, :step_name}` | `{:conditional, :step_name}` 元组。

---

## 对 Gong 的意义

Gong 作为 Agent 引擎，不需要自己实现协调系统。Jido 已经提供了：

- **单 Agent 内的任务编排** → Jido.Plan + Workflow
- **多 Agent 委派** → OrchestratorAgent
- **事件驱动协调** → Signal.Bus
- **执行历史** → Thread

Gong 需要补的是**持久化层**（已规划在 Phase 5 Tape Storage），
让 Plan 的执行状态可以在崩溃后恢复。这是 Gong 相对于原生 Jido 的增值。

如果未来需要 Beads 级别的跨 Agent 持久化协调，
可以考虑在 Jido.Plan 之上加一层 `Gong.Coordinator`：

```
Gong.Coordinator
├── 基于 Jido.Plan 做 DAG 编排
├── 基于 Gong.Tape.Store 做持久化
├── 基于 Jido.Signal.Bus 做跨 Agent 事件通知
└── 基于 Jido.Thread 做审计日志
```

这四个模块 Jido 都已提供，Gong 只需要做**胶水层**把它们串起来。
