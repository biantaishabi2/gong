# Gong (工) 实施计划

## 概述

本文档描述 Gong 项目从骨架到可用的完整实施路径。按依赖关系从底向上分 6 个阶段，每个阶段结束都有可验证的交付物。

### 依赖关系

```
工具 Actions (阶段一)
    ↓
截断系统 (阶段二)            Tape 存储 (阶段五) ←— 可与阶段三并行
    ↓                            ↓
Agent 循环 (阶段三)  ←———→  压缩 (阶段六上)
    ↓
Hook 系统 (阶段四)
    ↓
ZCPG 集成 (阶段六下)
```

### 测试基准

文档 `architecture.md` 第 J 节定义了 216 个 BDD 测试（含 20 个 Pi bug 回归 + 23 个 Hook 系统 + 14 个 压缩系统 + 34 个 Tape 存储 + 30 个 Agent 集成）。每个阶段实现完成后，对应的测试必须全部通过。当前全部 265 个 ExUnit 测试通过（部分 DSL 场景合并为同一测试）。

---

## 阶段一：7 个工具 Action ✅ 已完成

**目标**：所有工具 Action 的 `run/2` 实现完整功能，通过对应的 BDD 测试。

**前置条件**：无（纯函数式，不依赖 LLM 和外部服务）

### 实现顺序

按复杂度从低到高排列，每个工具做完立即写测试：

#### 1.1 read（文件读取）

- 对应模块：`Gong.Tools.Read`
- 对应测试：J.3 节，17 个用例
- 核心逻辑：
  - `File.stream!/1` 按行读取
  - `offset` + `limit` 分页
  - 行号前缀格式：`"     {n}\t{line}"`
  - 长行截断（超过 2000 字符的行截断并标记）
  - 文件不存在返回错误信息而非崩溃
- 边界情况：
  - 空文件返回空内容提示
  - 二进制文件检测（读前 8KB 检查 `\0` 字节）
  - offset 超出文件行数 → 返回空
  - 路径穿越校验（`../` 不能逃出工作区）

#### 1.2 ls（目录列表）

- 对应模块：`Gong.Tools.Ls`
- 对应测试：J.7 节，6 个用例
- 核心逻辑：
  - `File.ls!/1` + `File.stat/1` 获取元信息
  - 返回文件名、大小、类型（文件/目录/符号链接）
  - 结果按类型排序：目录优先，文件其次
- 边界情况：
  - 目录不存在 → 错误信息
  - 对文件路径调用 ls → 错误信息
  - 空目录 → 空列表
  - 大目录（>1000 条目）→ 截断并提示

#### 1.3 find（文件查找）

- 对应模块：`Gong.Tools.Find`
- 对应测试：J.6 节，6 个用例
- 核心逻辑：
  - `Path.wildcard/2` 执行 glob 匹配
  - 排除模式过滤（默认排除 `.git/`、`node_modules/`、`_build/`、`deps/`）
  - 结果按修改时间排序
  - 结果数量限制（默认 200）
- 边界情况：
  - 无匹配 → 空列表 + 提示
  - 符号链接不追踪（避免循环）

#### 1.4 grep（内容搜索）

- 对应模块：`Gong.Tools.Grep`
- 对应测试：J.5 节，10 个用例
- 核心逻辑：
  - `Regex.compile/2` 编译模式
  - 遍历文件，按行匹配
  - 支持上下文行数（`-A`/`-B`/`-C` 语义）
  - 输出模式：`content`（显示匹配行）、`files_with_matches`（只显示文件名）、`count`（显示计数）
  - glob 过滤搜索范围
- 边界情况：
  - 无效正则 → 友好错误信息
  - 二进制文件跳过
  - 结果过多 → 截断
  - 多文件匹配时按文件分组输出

#### 1.5 write（文件写入）

- 对应模块：`Gong.Tools.Write`
- 对应测试：J.4 节，7 个用例
- 核心逻辑：
  - `File.mkdir_p/1` 自动创建父目录
  - `File.write/3` 覆盖写入
  - 返回写入字节数
- 边界情况：
  - 路径穿越校验
  - 写入空字符串 → 创建空文件
  - 权限不足 → 错误信息
  - 写入到只读路径 → 错误信息

#### 1.6 edit（文件编辑）

- 对应模块：`Gong.Tools.Edit`
- 对应测试：J.1 节，23 个用例（最多）
- 核心逻辑：
  - 读文件 → 查找 `old_string` → 替换 → 写回
  - **唯一性校验**：`old_string` 在文件中必须恰好出现一次（除非 `replace_all: true`）
  - 多次匹配时报错并显示各匹配的行号
  - 零匹配时报错并提供模糊匹配建议
  - 保持原始换行符（CRLF 或 LF）
- 边界情况：
  - `old_string == new_string` → 报错，不做无意义替换
  - BOM 头处理（UTF-8 BOM 0xEF 0xBB 0xBF）
  - 包含正则特殊字符的字符串 → 精确匹配，不做正则
  - 路径穿越校验
  - `replace_all: true` 时返回替换次数

#### 1.7 bash（命令执行）

- 对应模块：`Gong.Tools.Bash`
- 对应测试：J.2 节，14 个用例
- 核心逻辑：
  - `System.cmd("bash", ["-c", command], opts)` 执行命令
  - 或用 `Port.open/2` 做更细粒度控制
  - 超时控制：`Task.async` + `Task.yield` + `Task.shutdown`
  - stdout 和 stderr 分离捕获
  - 输出超长时自动调用 `Gong.Truncate`
  - 工作目录设置（`cd: working_dir`）
- 边界情况：
  - 命令不存在 → exit_code 127 + 错误信息
  - 超时 → 杀进程 + 超时提示
  - 命令被信号终止 → 报告信号类型
  - 环境变量继承当前进程环境
  - 空命令 → 报错

### 阶段一交付物

- ✅ 7 个 Action 模块全部实现
- ✅ 85 个 BDD 测试通过（J.1 到 J.7，含 Pi bug 回归 + 参数校验与安全）
- ✅ 每个 Action 可以独立通过 `Jido.Action.run/2` 调用

---

## 阶段二：截断系统 ✅ 已完成

**目标**：完善 `Gong.Truncate`，返回结构化元数据，与工具输出对接。

**前置条件**：阶段一完成（截断要对接工具输出）

### 实现内容

#### 2.1 Result 结构体 + 双限制

重构 `Gong.Truncate`，返回 `%Gong.Truncate.Result{}` 替代旧的 `{text, boolean}` 元组：

```elixir
defmodule Gong.Truncate.Result do
  defstruct content: "",
            truncated: false,
            truncated_by: nil,        # :lines | :bytes | :chars | nil
            total_lines: 0,
            total_bytes: 0,
            output_lines: 0,
            output_bytes: 0,
            last_line_partial: false,
            first_line_exceeds_limit: false,
            max_lines: nil,
            max_bytes: nil
end
```

- `truncate_head`：逐行累加，`max_lines` + `max_bytes` 先触发者生效
- `truncate_tail`：从末尾逐行收集，边界行部分包含（UTF-8 安全）
- `truncate_line`：新增单行截断（用于 grep 单行限制），超 `max_chars` 则截断

#### 2.2 工具输出对接

三处调用改为解构 `%Result{}`：

- **read.ex**：字节截断后追加 `"Use offset=N to continue reading"` 续读提示
- **bash.ex**：截断后追加 `"原始 N 字节"` 原始大小信息
- **grep.ex**：简单解构 `%Result{content: truncated}`

#### 2.3 BDD 测试

新增指令：
- **GIVEN**: `set_var`、`generate_content`（内存数据准备，不依赖文件系统）
- **WHEN**: `truncate_head`、`truncate_tail`、`truncate_line`（直接调用截断模块）
- **THEN**: `assert_truncation_result`、`assert_truncation_notification`（结构化断言）

DSL 文件：`docs/bdd/truncate_system.dsl`，14 个场景（BDD-TRC-001 ~ 014）

### 阶段二交付物

- ✅ 截断系统 14 个测试通过（J.8 节，含 2 个 Pi bug 回归）
- ✅ 阶段一 85 个测试无回归
- ✅ 工具 + 截断合计 **99 个测试通过**
- ✅ `mix compile --warnings-as-errors` 无警告

---

## 阶段三：Agent 循环 ✅ 已完成

**目标**：LLM 调用 + 工具执行形成完整的 agent loop。

**前置条件**：阶段一、二完成

**外部依赖**：需要 LLM API key（Anthropic 或 OpenAI）

### 实现内容

#### 3.1 工具注册与 schema 转换

jido_ai 的 `ToolAdapter` 自动把 Jido Action 转成 LLM 的 tool schema：

```elixir
# Jido Action 的 schema 定义
schema: [
  file_path: [type: :string, required: true, doc: "文件绝对路径"],
  offset: [type: :non_neg_integer, default: 0, doc: "起始行号"]
]

# ↓ 自动转换为 ↓

# LLM tool_call 的 JSON Schema
%{
  "name" => "read_file",
  "description" => "读取文件内容，支持分页",
  "input_schema" => %{
    "type" => "object",
    "properties" => %{
      "file_path" => %{"type" => "string", "description" => "文件绝对路径"},
      "offset" => %{"type" => "integer", "description" => "起始行号"}
    },
    "required" => ["file_path"]
  }
}
```

需要验证 7 个 Action 的 schema 都能正确转换。

#### 3.2 Agent 循环实现

新建 `Gong.AgentLoop` 模块，核心流程：

```
用户消息 → 拼装上下文（系统提示 + 历史 + 工具列表）
    → 调 LLM（ReqLLM）
    → 解析响应
    → 如果有 tool_call → 执行对应 Action → 结果回传 → 继续循环
    → 如果是纯文本 → 返回给用户
    → 如果请求结束 → 退出循环
```

利用 jido_ai 的 `ReAct` 策略，不需要手写循环状态机：

```elixir
# jido_ai 已经封装了 ReAct 循环
Jido.AI.Agent.run(agent, signal, strategy: :react)
```

需要确认 `ReAct` 策略的以下行为：
- 最大循环次数限制（防止无限 tool_call）
- tool_call 失败时的错误恢复
- 多个 tool_call 的并行执行（Anthropic 支持）

#### 3.3 系统提示词

新建 `Gong.Prompt` 模块：

```elixir
defmodule Gong.Prompt do
  def system_prompt(workspace) do
    """
    你是一个通用 Agent，工作目录是 #{workspace}。
    使用提供的工具完成用户的任务。
    ...
    """
  end
end
```

系统提示词从 `Gong.Agent` 的 schema 中的 `system_prompt` 字段注入，支持用户自定义覆盖。

#### 3.4 流式输出

LLM 的响应支持 SSE 流式输出：

```elixir
ReqLLM.chat(model, messages, tools: tools, stream: true)
|> Stream.each(fn chunk -> send(caller, {:chunk, chunk}) end)
```

这是 ZCPG 集成的关键——ZCPG 的 SSE client 需要实时接收 token。

### 阶段三交付物

- ✅ `Gong.AgentLoop` 模块实现
- ✅ `Gong.Prompt` 模块实现
- ✅ 30 个集成测试通过（J.9 节，含流式输出、Hook 端到端、错误恢复与健壮性）
- ✅ 可以在 IEx 中手动跑完整的 agent 对话

---

## 阶段四：Hook 系统 ✅ 已完成

**目标**：实现事件拦截与数据变换基础设施，在工具执行、LLM 调用、会话操作等关键节点插入用户自定义逻辑。

**前置条件**：阶段三完成（Hook 的集成点在 Agent 循环中）

### 实现内容

#### 4.1 Hook Behaviour 定义

新建 `Gong.Hook` behaviour，定义 3 类回调：

```elixir
defmodule Gong.Hook do
  @doc "Gate 型：拦截操作，返回 :ok 放行或 {:block, reason} 阻止"
  @callback before_tool_call(tool :: atom(), params :: map()) ::
    :ok | {:block, String.t()}
  @callback before_session_op(op :: atom(), meta :: map()) ::
    :ok | :cancel

  @doc "Pipe 型：变换数据流，返回修改后的数据"
  @callback on_tool_result(tool :: atom(), result :: map()) :: map()
  @callback on_context(messages :: [map()]) :: [map()]
  @callback on_input(text :: String.t(), images :: [map()]) ::
    {:transform, String.t(), [map()]} | :passthrough | :handled

  @doc "Notify 型：观察事件，通过 :telemetry 广播"
  @callback on_before_agent(prompt :: String.t(), system :: String.t()) ::
    {String.t(), String.t(), [map()]}

  @optional_callbacks [before_tool_call: 2, before_session_op: 2,
    on_tool_result: 2, on_context: 1, on_input: 2, on_before_agent: 2]
end
```

#### 4.2 HookRunner 实现

新建 `Gong.HookRunner`，两个核心函数：

- **`pipe/3`**：Enum.reduce 链式调用，每个 hook 变换数据后传给下一个
- **`gate/2`**：Enum.reduce_while 链式调用，任一 hook 返回 block 则终止

错误隔离：单个 hook 异常不影响其他 hook，通过 try/rescue 捕获并发 telemetry 事件。

#### 4.3 Agent 循环集成

在 `Gong.AgentLoop` 的 5 个关键节点插入 hook 调用：

1. 用户输入进入前 → `on_input`
2. 构建上下文时 → `on_context`
3. 调 LLM 前 → `on_before_agent`
4. 工具执行前 → `before_tool_call`（gate）
5. 工具执行后 → `on_tool_result`（pipe）

#### 4.4 Telemetry 事件

注册标准 telemetry 事件供外部监控：

- `[:gong, :tool, :start]` / `[:gong, :tool, :stop]`
- `[:gong, :llm, :start]` / `[:gong, :llm, :stop]`
- `[:gong, :hook, :error]`

### 阶段四交付物

- ✅ `Gong.Hook` behaviour 模块
- ✅ `Gong.HookRunner` 实现模块（含 gate 异常值 catch-all）
- ✅ Agent 循环 5 个集成点改造
- ✅ 23 个 Hook 系统 BDD 测试通过（J.10 节，含 short-circuit、passthrough、telemetry 序列验证）

---

## 阶段五：Tape 存储 ✅ 已完成

**目标**：实现文件夹 + SQLite 索引的会话存储。

**前置条件**：无（独立模块，可与阶段三并行开发）

### 实现内容

#### 5.1 SQLite schema 初始化

```elixir
defp init_db(db_path) do
  {:ok, conn} = Exqlite.Sqlite3.open(db_path)

  Exqlite.Sqlite3.execute(conn, """
    CREATE TABLE IF NOT EXISTS entries (
      id          INTEGER PRIMARY KEY AUTOINCREMENT,
      kind        TEXT NOT NULL,
      anchor_name TEXT NOT NULL,
      anchor_seq  INTEGER NOT NULL,
      file_path   TEXT NOT NULL,
      line_offset INTEGER,
      created_at  TEXT NOT NULL,
      summary     TEXT
    )
  """)

  # 建索引...
  # 建 FTS5 虚拟表...
end
```

或者用 Ecto + ecto_sqlite3 做 migration（更规范但更重）。

**决策点**：直接用 Exqlite 还是走 Ecto？
- Exqlite 直接 SQL：轻量，适合嵌入式场景，代码更少
- Ecto migration：规范，有 schema 版本管理，但引入 Repo 概念

建议先用 Exqlite 直接写，后续需要再抽 Ecto。

#### 5.2 核心操作实现

按顺序：

1. **`init/1`** — 创建 `anchors/` 目录 + `index.db` + 默认 anchor `001_session-start`
2. **`append/3`** — 写 JSONL 文件 + INSERT SQLite，用事务包裹
3. **`handoff/3`** — 创建新 anchor 目录 + INSERT anchor 记录
4. **`between_anchors/3`** — SQL 范围查询 → 定位文件 → 读 JSONL
5. **`search/2`** — FTS5 全文搜索 → 定位文件 → 读完整条目
6. **`fork/1`** — SQLite savepoint + 临时目录
7. **`merge/2`** — 合并临时目录到主目录 + 合并 SQLite 记录

#### 5.3 一致性保证

双写的原子性问题：

```elixir
def append(store, anchor, entry) do
  # 先写文件（追加，低风险）
  :ok = write_jsonl(file_path, entry)

  # 再写数据库（事务）
  {:ok, _} = insert_index(store.db, entry_meta)

  # 如果数据库写入失败，文件多了一行但索引没有
  # → 下次启动时可以通过扫描文件修复索引（rebuild_index）
end
```

添加 `rebuild_index/1` 函数：扫描 anchors/ 目录重建 SQLite 索引。

### 阶段五交付物

- ✅ `Gong.Tape.Store` 完整实现（含 Entry、FileStore、Index 三模块）
- ✅ 34 个 Tape 存储 BDD 测试通过（J.11 节，含双写一致性、fork/merge、metadata 存取、Pi bug 回归）
- ✅ SQLite 索引支持 metadata 字段，FTS5 全文搜索可用

---

## 阶段六：压缩 + ZCPG 集成

**目标**：上下文压缩可用，Gong 接入 ZCPG 替换 OpenCode。

**前置条件**：阶段三、四、五完成

### 6a. 上下文压缩 ✅ 已完成

#### 实现内容

新建或完善 `Gong.Compaction`：

```elixir
def compact(messages, opts) do
  window = Keyword.get(opts, :window_size, 20)
  max_tokens = Keyword.get(opts, :max_tokens, 100_000)

  if estimate_tokens(messages) <= max_tokens do
    {messages, nil}
  else
    {old, recent} = Enum.split(messages, -window)
    summary = summarize(old)  # 调 LLM 生成摘要
    {[%{role: "system", content: summary} | recent], summary}
  end
end
```

核心逻辑：
- Token 估算：按字符数粗估（中文 1 字 ≈ 2 token，英文 1 word ≈ 1.3 token）
- 滑动窗口：保留最近 N 条完整消息
- 摘要生成：调 LLM 对旧消息生成结构化摘要
- 系统消息和 anchor 消息不参与压缩，始终保留

#### 与 Tape 配合

压缩触发时，同时在 Tape 中创建新 anchor：

```elixir
def compact_and_handoff(tape_store, messages, opts) do
  {compacted, summary} = compact(messages, opts)
  if summary do
    Gong.Tape.Store.handoff(tape_store, "compaction", %{summary: summary})
  end
  compacted
end
```

### 6b. ZCPG 集成 ⏸️ 暂缓

#### 当前 ZCPG 架构

ZCPG 通过 `Zcpg.AI.AgentClient` behaviour 调用外部 agent：

```elixir
# 当前实现：HTTP 调 OpenCode (127.0.0.1:4096)
defmodule Zcpg.AI.Adapters.OpenCode do
  @behaviour Zcpg.AI.AgentClient

  def create_session(opts), do: ...   # POST /sessions
  def call(session, agent, input, opts), do: ...  # POST /sessions/:id/chat
  def stream(session, agent, input, callback, opts), do: ...  # SSE
  def abort(session, reason), do: ...
end
```

#### 新适配器

在 ZCPG 项目中新建 `Zcpg.AI.Adapters.Gong`：

```elixir
defmodule Zcpg.AI.Adapters.Gong do
  @behaviour Zcpg.AI.AgentClient

  def create_session(opts) do
    # 不再 HTTP，直接在 BEAM 内启动 Gong agent 进程
    {:ok, pid} = DynamicSupervisor.start_child(
      Gong.SessionSupervisor,
      {Gong.AgentLoop, workspace: opts[:workspace]}
    )
    {:ok, %{pid: pid, session_id: inspect(pid)}}
  end

  def call(session, _agent, input, _opts) do
    Gong.AgentLoop.chat(session.pid, input)
  end

  def stream(session, _agent, input, callback, _opts) do
    Gong.AgentLoop.stream(session.pid, input, callback)
  end

  def abort(session, _reason) do
    Gong.AgentLoop.cancel(session.pid)
  end
end
```

#### 集成步骤

1. ZCPG 的 `mix.exs` 添加 `{:gong, path: "../gong"}` 依赖
2. 新建 `Zcpg.AI.Adapters.Gong` 模块
3. 配置切换：`config :zcpg, :agent_adapter, Zcpg.AI.Adapters.Gong`
4. 保留 OpenCode 适配器作为回退
5. 验证 4 个 agent 场景：kb-triage、kb-answer、rlm-planner、build

#### 配置示例

```elixir
# config/config.exs
config :zcpg, :agent_adapter, Zcpg.AI.Adapters.Gong

config :gong,
  model: "anthropic/claude-sonnet-4-5-20250929",
  api_key: System.get_env("ANTHROPIC_API_KEY")
```

### 阶段六交付物

**6a 已完成：**
- ✅ `Gong.Compaction` 完整实现（含 Token 估算、滑动窗口、ETS 锁、fallback 截断）
- ✅ 14 个压缩系统 BDD 测试通过（J.12 节，含 summarize_fn 崩溃、锁隔离、window 边界等）

**6b 暂缓：**
- `Zcpg.AI.Adapters.Gong` 适配器（待后续启动）
- ZCPG 可通过配置切换使用 Gong 或 OpenCode
- 端到端验证：ZCPG 页面发消息 → Gong agent 处理 → 流式返回

---

## 里程碑总结

| 阶段 | 交付物 | 累计测试 | 外部依赖 | 状态 |
|------|--------|----------|----------|------|
| 一 | 7 个工具 Action 完整实现 | 85 | 无 | ✅ 完成 |
| 二 | 截断系统 + 工具对接 | 99 | 无 | ✅ 完成 |
| 三 | Agent 循环 + LLM 调用 | 129 | LLM API key | ✅ 完成 |
| 四 | Hook 系统 | 152 | 无 | ✅ 完成 |
| 五 | Tape 存储（文件夹 + SQLite） | 186 | 无 | ✅ 完成 |
| 六a | 压缩系统 | 200 | 无 | ✅ 完成 |
| 七 | 架构缺口补全（20 个新 BDD 场景） | ~220 | 无 | 📋 待实现 |
| 六b | ZCPG 集成 | — | ZCPG 项目 | ⏸️ 暂缓 |

### 并行度

```
时间线 →

阶段一 ████████████
阶段二          ████
阶段三              ████████████
阶段四                          ████
阶段五          ████████████████████  ← 可与二、三、四并行
阶段六                              ████████
```

阶段五（Tape 存储）是完全独立的模块，可以在阶段二开始后随时并行推进。
阶段四（Hook 系统）依赖阶段三的 Agent 循环，因为 Hook 的集成点在循环中。

### 风险点

1. **jido_ai 的 ReAct 策略** — main 分支未发布到 hex，API 可能变动。应对：pin commit hash
2. **Elixir 版本** — jido_browser 和 yaml_elixir 要求 1.18，当前系统是 1.17.3。应对：升级 Elixir 或排除 jido_browser
3. **tool_call 格式兼容** — 不同 LLM 提供商的 tool_call 格式有细微差异。应对：先锁定 Anthropic，其他提供商留位
4. **Tape 双写一致性** — 文件写成功但 SQLite 写失败。应对：rebuild_index 修复机制

---

## 架构文档缺口清单（从 pi-mono 对比发现）

以下特性在 `架构设计.md` 中有描述，但在之前的实施计划中遗漏，导致未实现。按优先级分组列出，每项标注架构文档出处和 BDD 覆盖状态。

### P0：Agent 循环核心能力

#### 7.1 Steering 中断

用户在 Agent 执行工具链期间发送新消息，应能打断当前执行。

- **架构出处**：Section 2.2（双层循环 steering 机制）、J.9 test 1.4
- **当前状态**：❌ 未实现，❌ 无 BDD 场景
- **实现要点**：
  - Agent 每执行完一个 tool_call 后检查 steering 消息队列
  - 有 steering 时跳过剩余 tool_call，标记为 `"Skipped due to queued user message"`
  - OTP 实现：`GenServer.cast` 注入 steering，`check_steering/1` 从 mailbox 读取
- **BDD 场景**（需新增）：
  - `BDD-AGENT-031`：steering 中断跳过剩余工具
  - `BDD-AGENT-032`：steering 消息在下一轮被正确处理

#### 7.2 Auto-Retry（自动重试）

LLM API 返回 429/overloaded/server error 时自动指数退避重试。

- **架构出处**：J.9 tests 4.3, 4.7, 5.1, 5.4, 5.6
- **当前状态**：❌ 未实现，❌ 无 BDD 场景
- **实现要点**：
  - 检测可重试错误（429 Too Many Requests、overloaded、5xx）
  - 指数退避：1s → 2s → 4s → 8s，最多 3 次
  - 429 不触发压缩（Pi bug #1038 回归）
  - retry 在工具执行完成后才 resolve（Pi bug #1465 回归）
- **BDD 场景**（需新增）：
  - `BDD-AGENT-033`：429 触发重试而非压缩
  - `BDD-AGENT-034`：重试成功后正常继续
  - `BDD-AGENT-035`：重试耗尽返回错误

#### 7.3 Auto-Compaction（自动压缩）

Agent 对话后自动检测上下文溢出并触发压缩。

- **架构出处**：Section 6.1（触发条件）、J.9 tests 4.3, 4.4
- **当前状态**：❌ 未实现（当前需手动调用 `compact/2`），❌ 无 BDD 场景
- **实现要点**：
  - 每轮 Agent 结束后检查：`contextTokens > (contextWindow - reserveTokens)`
  - `reserveTokens` 默认 16384
  - 压缩期间排队的用户消息不丢失（Pi bug #1312 回归）
- **BDD 场景**（需新增）：
  - `BDD-AGENT-036`：上下文超限自动触发压缩
  - `BDD-AGENT-037`：压缩期间排队消息恢复

#### 7.4 Pi Bug 回归补全

架构文档 J.9 section 4 定义了 7 个 Pi Bug 回归测试，其中 4.3/4.4/4.7 已映射到 BDD-AGENT-033~037。以下 4 个回归测试缺 BDD 场景：

- **架构出处**：J.9 tests 4.1, 4.2, 4.5, 4.6
- **当前状态**：❌ 无 BDD 场景
- **BDD 场景**（需新增）：
  - `BDD-AGENT-038`：并发 prompt 竞态防护（Pi #403）— Agent 处理中收到第二个 prompt → 拒绝或排队，不并发执行
  - `BDD-AGENT-039`：孤儿 tool_result 清理（Pi #1454/#1455）— 中断的 tool_call 遗留的 tool_result 被自动清理，下一轮 API 不报 400
  - `BDD-AGENT-040`：非数组 content 不崩溃（Pi #1434）— LLM 返回 content 为纯字符串（非 list），Agent 正常处理
  - `BDD-AGENT-041`：多 tool_call 结果不错位（Pi #1446）— 单轮 3 个 tool_call (read A/B/C)，每个 tool_result 精确对应原始 tool_call_id

### P1：Compaction 增强

#### 7.4 Token 预算窗口（替代消息数窗口）

当前按消息数切（`window_size=20`），应改为按 token 预算切（`keepRecentTokens=20000`）。

- **架构出处**：Section 6.1/6.2（keepRecentTokens）
- **当前状态**：⚠️ 实现与架构不一致（用消息数代替 token 预算），✅ BDD 有 max_tokens 阈值测试但窗口本身未测
- **实现要点**：
  - 从最新消息往回遍历，累加 token 估算值
  - 累计超过 `keepRecentTokens`（默认 20000）时确定切割点
  - 切割点必须在有效边界（见 7.5）

#### 7.5 tool_call/result 配对保护

压缩切割时不能把 tool_call 和对应的 tool_result 拆开。

- **架构出处**：Section 6.2 step 3-4、J.9 tests 4.2, 4.6
- **当前状态**：❌ 未实现，❌ 无 BDD 场景
- **实现要点**：
  - 切割点只能落在 user/assistant 消息边界
  - 不能切在 tool_result 中间
  - 如果切在带 tool_calls 的 assistant 消息中间，生成转折摘要
  - 孤儿 tool_result 清理
- **BDD 场景**（需新增）：
  - `BDD-COMPACT-015`：切割点跳过 tool_result 到前一个 user 消息
  - `BDD-COMPACT-016`：孤儿 tool_result 被清理

#### 7.6 结构化摘要 Prompt

压缩摘要应使用结构化模板，而非随意生成。

- **架构出处**：Section 6.2 step 5
- **当前状态**：❌ 未实现（当前 `summarize_fn` 委托外部），❌ 无 BDD 场景
- **实现要点**：
  - Compaction 模块内置默认 `summarize_fn`，构建结构化 prompt
  - 摘要模板包含 6 个分类：Goal、Constraints & Preferences、Progress（Done/In Progress/Blocked）、Key Decisions、Next Steps、Critical Context
  - 追加文件操作记录（read/write/edit 汇总）
  - 使用独立 system prompt 防止模型续写对话
- **BDD 场景**（需新增）：
  - `BDD-COMPACT-017`：mock summarize_fn 捕获输入，断言包含结构化字段标记（Goal、Progress 等）
  - `BDD-COMPACT-018`：摘要输入包含文件操作汇总

#### 7.7 迭代摘要更新

当已有前次压缩摘要时，增量更新而非从头生成。

- **架构出处**：Section 6.2 step 7
- **当前状态**：❌ 未实现，❌ 无 BDD 场景
- **实现要点**：
  - 检测是否已有 compaction summary 条目
  - 有 → 使用 UPDATE_SUMMARIZATION_PROMPT 增量合并新信息
  - 无 → 使用完整 SUMMARIZATION_PROMPT
- **BDD 场景**（需新增）：
  - `BDD-COMPACT-019`：首次压缩，summarize_fn 收到完整 SUMMARIZATION prompt
  - `BDD-COMPACT-020`：二次压缩，summarize_fn 收到 UPDATE prompt + 前次摘要内容

### P2：工具层补全

#### 7.8 Edit BOM/CRLF 处理 + Diff 生成

架构文档 Section A 详细描述了 10 步 edit 流程，当前实现缺少 BOM、CRLF、diff 三块。

- **架构出处**：Section A steps 4-6, 9-10；J.1 tests 3.1-3.5, 5.3
- **当前状态**：❌ 未实现，❌ 无 BDD 场景（DSL 文件注释已标"待后续补充"）
- **实现要点**：
  - BOM 检测（`\uFEFF`）→ 剥离 → 匹配/替换 → 恢复
  - CRLF 检测 → 统一转 LF → 匹配/替换 → 恢复原始行尾
  - Diff 生成：4 行上下文 unified diff + `first_changed_line`
- **BDD 场景**（需新增，对应 J.1 tests 3.x, 5.3）：
  - `BDD-EDIT-017`：CRLF 文件跨平台匹配
  - `BDD-EDIT-018`：CRLF 行尾保留
  - `BDD-EDIT-019`：LF 行尾保留（无 `\r\n` 注入）
  - `BDD-EDIT-020`：混合行尾重复检测
  - `BDD-EDIT-021`：BOM + CRLF 联合保留
  - `BDD-EDIT-022`：diff 行号正确性（远离文件开头）

#### 7.9 Find 尊重 .gitignore

当前用 `Path.wildcard`，不支持 `.gitignore`。架构文档指定用 `fd` + `--ignore-file`。

- **架构出处**：Section F；J.6 test 2.1
- **当前状态**：❌ 未实现，❌ 无 BDD 场景
- **实现要点**：
  - 收集目录树中所有 `.gitignore` 文件
  - 改用 `fd` 命令或手动解析 `.gitignore` 规则
  - 结果仍按修改时间排序
- **BDD 场景**（需新增）：
  - `BDD-FIND-008`：.gitignore 中的文件不出现在结果里

#### 7.10 Bash 大输出滚动缓冲 + 临时文件

当前 bash 输出超限直接截断丢弃。架构文档要求写临时文件保留完整输出。

- **架构出处**：Section B；J.2 tests 3.1, 3.2
- **当前状态**：❌ 未实现，❌ 无 BDD 场景
- **实现要点**：
  - 内存保留最近 100KB 滚动缓冲区
  - 总输出 > 50KB 时写临时文件 `/tmp/gong-bash-{random}.log`
  - 截断通知包含临时文件路径
- **BDD 场景**（需新增）：
  - `BDD-BASH-015`：大输出创建临时文件
  - `BDD-BASH-016`：截断通知包含文件路径

---

## BDD 覆盖缺口汇总

| 缺口 | 需新增场景 | 对应架构测试 |
|------|-----------|-------------|
| Steering 中断 | BDD-AGENT-031~032 | J.9 test 1.4 |
| Auto-retry | BDD-AGENT-033~035 | J.9 tests 4.3, 4.7, 5.1 |
| Auto-compaction | BDD-AGENT-036~037 | J.9 tests 4.3, 4.4 |
| tool_call/result 配对 | BDD-COMPACT-015~016 | J.9 tests 4.2, 4.6; Section 6.2 |
| 结构化摘要 prompt | BDD-COMPACT-017~018 | Section 6.2 step 5 |
| 迭代摘要更新 | BDD-COMPACT-019~020 | Section 6.2 step 7 |
| Edit BOM/CRLF/Diff | BDD-EDIT-017~022 | J.1 tests 3.1-3.5, 5.3 |
| Find .gitignore | BDD-FIND-008 | J.6 test 2.1 |
| Bash 临时文件 | BDD-BASH-015~016 | J.2 tests 3.1, 3.2 |
| Pi Bug 回归补全 | BDD-AGENT-038~041 | J.9 tests 4.1, 4.2, 4.5, 4.6 |
| **合计** | **24 个新场景** | |

---

## 阶段八：Pi-mono 功能对齐

**目标**：补齐与 pi-mono 核心功能的差距，使 Gong 具备产品级 Agent 引擎能力。

**前置条件**：阶段七完成（内部改进场景全部通过）

### 功能对齐总表

| # | 功能 | 优先级 | pi-mono 测试数 | Gong 现有测试 | 需新增 BDD 场景 |
|---|------|--------|---------------|-------------|----------------|
| 1 | 流式输出 | 🔴 高 | 110 | 2（基础 mock） | 8 |
| 2 | 多模型运行时切换 | 🔴 高 | 38 | 0 | 6 |
| 3 | Session 树形分支 | 🟡 中 | 13 | 8（线性 fork） | 6 |
| 4 | Abort 信号传播 | 🟡 中 | 21 | 2（steering） | 5 |
| 5 | Extension 加载/发现 | 🟡 中 | 45 | 0 | 6 |
| 6 | Follow-up 消息队列 | 🟢 低 | 1 | 0 | 2 |
| 7 | Settings 管理 | 🟢 低 | 10 | 1（configure_agent） | 3 |
| 8 | Resource 发现 | 🟢 低 | 14 | 0 | 3 |
| 9 | 分支摘要 | 🟢 低 | 32 | 0 | 2 |
| 10 | truncate 工具 | 🟢 低 | 6 | 14（系统截断） | 2 |
| 11 | edit-diff 工具 | 🟢 低 | 42 | 22（字符串替换） | 3 |
| 12 | path-utils 工具 | 🟢 低 | 10 | 0（各工具内部处理） | 2 |
| | **合计** | | **342** | **49** | **48** |

---

### P0：流式输出（8 个场景）

**架构出处**：Section 2.4（流式消息管理）、Section 9 流式 LLM
**pi-mono 测试**：`packages/ai/test/stream.test.ts` — 110 个用例（1,336 行），覆盖 text/thinking/toolcall 三类流式事件、跨 Provider 流式、中断恢复
**Gong 现状**：
- `agent_integration.dsl` 有 BDD-AGENT-027（stream 事件序列）和 BDD-AGENT-028（stream + tool calls），仅 mock 级别
- `instructions_v1.ex` 有 `agent_stream` 指令但仅验证事件类型
- **无真实 LLM 流式**，LiveLLM 使用 `ReqLLM.generate_text`（非流式）

**实现要点**：
- ReqLLM 已支持 `ReqLLM.stream_text/3`，返回 `Stream` 枚举
- 在 LiveLLM 中增加 `stream_chat/4`，逐 chunk 推送事件
- MockLLM 增加 mock stream 支持（模拟 partial message 到达）
- 流式中断：stream 过程中收到 steering 消息 → 中止流、保留已接收内容

**BDD 场景**（需新增）：
- `BDD-STREAM-001`：纯文本流式 — mock LLM 分 3 次推送 text delta，最终拼接完整
- `BDD-STREAM-002`：tool call 流式 — 流式传输 tool call 参数 JSON
- `BDD-STREAM-003`：流式中断 — stream 进行中推送 steering，剩余 chunk 丢弃
- `BDD-STREAM-004`：空内容中断 — stream 刚开始（无实质内容）时中断 → 丢弃 partial message
- `BDD-STREAM-005`：流式事件序列 — 断言 start → delta（多次）→ end 顺序
- `BDD-STREAM-006`：流式 + Hook on_context — Hook 在流式前变换上下文
- `BDD-STREAM-007`：流式超时 — LLM 停止推送超过阈值 → 超时错误
- `BDD-STREAM-008`：E2E 真实 LLM 流式 — 使用 `stream_chat_live` 调用真实 DeepSeek 流式 API

---

### P0：多模型运行时切换（6 个场景）

**架构出处**：Section 1 架构图（Agent Session 层"模型切换"）
**pi-mono 测试**：`packages/coding-agent/test/model-registry.test.ts` — 38 个用例（798 行），覆盖 BaseURL 覆盖、自定义模型合并、API Key 缓存、动态刷新
**Gong 现状**：
- `Gong.Agent` 硬编码 `model: "deepseek:deepseek-chat"`
- `Gong.Providers.DeepSeek` 只注册了 DeepSeek 一个 Provider
- ReqLLM 底层已支持 17+ Provider，但 Gong 无运行时切换机制
- **无 BDD 场景**

**实现要点**：
- 新增 `Gong.ModelRegistry` 模块：注册可用模型、运行时查询、切换
- Agent 初始化时从 config/env 读取默认模型
- 支持运行时 `switch_model/2`（通过 strategy state 传递）
- API Key 按 Provider 从环境变量读取（`DEEPSEEK_API_KEY`、`OPENAI_API_KEY` 等）

**BDD 场景**（需新增）：
- `BDD-MODEL-001`：默认模型配置 — configure_agent 指定 model，agent 使用该模型
- `BDD-MODEL-002`：运行时切换 — 首轮用 model A，中途切换到 model B，第二轮用新模型
- `BDD-MODEL-003`：无效模型回退 — 指定不存在的 model → 回退到默认
- `BDD-MODEL-004`：API Key 缺失 — 指定 Provider 但无对应 API Key → 友好错误
- `BDD-MODEL-005`：多 Provider 注册 — 同时注册 DeepSeek + OpenAI，按名选择
- `BDD-MODEL-006`：E2E 真实切换 — 使用真实 API 验证模型切换后响应格式正确

---

### P1：Session 树形分支（6 个场景）

**架构出处**：Section 7（会话管理，"支持从任意节点分支"）、Tape存储重设计.md
**pi-mono 测试**：
- `agent-session-branching.test.ts` — 3 个用例（156 行）：fork 单条消息、内存 fork、中间 fork
- `agent-session-tree-navigation.test.ts` — 10 个用例（319 行）：树导航和分支操作
**Gong 现状**：
- Tape 有 fork/merge（BDD-TAPE-013~016, 027, 030, 032 共 8 个场景）
- 但是**线性 anchor 模型**，fork 是复制而非树形分支
- 无 leafId 指针、无分支导航、无分支间切换

**实现要点**：
- Tape.Store 增加 `branch_from/2`：从指定 anchor 创建分支
- Index 增加 `parent_anchor_id` 字段支持树形关系
- `navigate/2`：切换到指定分支的叶节点
- `branches/1`：列出当前 anchor 的所有分支
- 上下文构建时沿分支路径回溯到根

**BDD 场景**（需新增）：
- `BDD-SESSION-001`：从中间 anchor 分支 — 第 3 个 anchor 处 branch，两条路径独立
- `BDD-SESSION-002`：分支导航 — 在两个分支间切换，各自内容正确
- `BDD-SESSION-003`：分支上下文构建 — 在分支 B 上 build context 只包含根→B 路径
- `BDD-SESSION-004`：深度分支 — 分支的分支（3 层树），导航到叶节点正确
- `BDD-SESSION-005`：分支后追加 — 分支后在新路径追加消息不影响原路径
- `BDD-SESSION-006`：分支列表 — branches/1 返回所有直接子分支

---

### P1：Abort 信号传播（5 个场景）

**架构出处**：Section 2.4（abort 中断判断）、Section B（bash abort）
**pi-mono 测试**：`packages/ai/test/abort.test.ts` — 21 个用例（260 行），覆盖中途 abort、立即 abort、abort 后续对话、跨 Provider abort
**Gong 现状**：
- Steering 系统有 2 个场景（BDD-STEER-001~002），仅测队列操作
- OTP 进程可以被杀，但无结构化的 abort 传播
- 工具执行中无 abort 检查
- LLM 调用中无中断机制

**实现要点**：
- 新增 `Gong.Abort` 模块：基于 `Process.flag(:trap_exit, true)` + 信号
- Agent 循环每步检查 abort 状态（tool 执行前、LLM 调用前）
- Bash 工具：abort 时杀进程树（已有 `kill_process_tree`，需挂接信号）
- LLM 流式：abort 时关闭连接（ReqLLM 支持 cancel）
- 被 abort 的 partial 内容保留但标记为 incomplete

**BDD 场景**（需新增）：
- `BDD-ABORT-001`：工具执行中 abort — bash 运行耗时命令，发送 abort → 进程被杀、返回中断结果
- `BDD-ABORT-002`：多工具 abort — 3 个 pending tools，第 1 个执行后 abort → 剩余 2 个跳过
- `BDD-ABORT-003`：LLM 等待中 abort — 等待 LLM 响应时 abort → 返回 aborted 错误
- `BDD-ABORT-004`：abort 后恢复 — abort 后发送新 prompt，agent 正常响应
- `BDD-ABORT-005`：partial content 保留 — LLM 已返回部分内容时 abort → 保留 partial 文本

---

### P1：Extension 加载/发现（6 个场景）

**架构出处**：Section 10（后续扩展"+1000 行"）
**pi-mono 测试**：
- `extensions-runner.test.ts` — 18 个用例（510 行）：快捷命令冲突、工具收集、错误处理
- `extensions-discovery.test.ts` — 27 个用例（463 行）：.ts/.js 发现、子目录 index、嵌套发现
**Gong 现状**：
- `Gong.Hook` behaviour 定义 6 个回调 — 这是 Gong 的"拦截"机制
- 但无运行时插件发现/加载：Hook 模块必须在编译时注册
- Jido 有 plugin system（`Jido.Plugin`）但 Gong 未使用
- **无 BDD 场景**

**实现要点**：
- 新增 `Gong.Extension.Loader`：扫描 `~/.gong/extensions/` 和 `{workspace}/.gong/extensions/`
- 支持 `.ex` 文件动态编译加载（`Code.compile_file/1`）
- Extension 接口继承 `Gong.Hook` + 增加 `tools/0`（自定义工具）和 `commands/0`（斜杠命令）
- `Gong.Extension.Runner`：生命周期管理（load → init → run → cleanup）
- 错误隔离：单个 extension 崩溃不影响 Agent

**BDD 场景**（需新增）：
- `BDD-EXTEND-001`：发现 .ex 文件 — 在 extensions/ 放置 .ex → Loader 发现并加载
- `BDD-EXTEND-002`：Hook 回调注册 — 加载的 Extension 的 before_tool_call 生效
- `BDD-EXTEND-003`：自定义工具注册 — Extension 提供的工具出现在可用工具列表
- `BDD-EXTEND-004`：加载失败隔离 — 有语法错误的 .ex 文件 → 跳过并记录错误，其他 Extension 不受影响
- `BDD-EXTEND-005`：多 Extension 优先级 — 两个 Extension 定义同名工具 → 后加载覆盖
- `BDD-EXTEND-006`：Extension 生命周期 — 加载 → init 回调 → Agent 运行 → cleanup 回调

---

### P2：Follow-up 消息队列（2 个场景）

**架构出处**：Section 2.2（三种消息注入机制 — follow-up）
**pi-mono 测试**：`agent-session-auto-compaction-queue.test.ts` — 1 个用例（97 行）
**Gong 现状**：
- 仅有 Steering 单一队列
- Agent 循环无外层 follow-up 检查
- 多轮对话通过外部调用 `agent_chat_continue` 实现

**实现要点**：
- Steering 增加 `push_follow_up/2`：区分"中断消息"和"后续消息"
- Agent 循环完成后检查 follow-up 队列，有则自动继续

**BDD 场景**（需新增）：
- `BDD-FOLLOWUP-001`：Agent 完成后有 follow-up → 自动开始下一轮
- `BDD-FOLLOWUP-002`：follow-up 与 steering 同时存在 → steering 优先中断当前，follow-up 排队

---

### P2：Settings 管理（3 个场景）

**架构出处**：无直接出处（pi-mono 特有功能）
**pi-mono 测试**：`settings-manager.test.ts` — 10 个用例（227 行），覆盖外部修改保留、主题切换、内存覆盖
**Gong 现状**：
- 使用 `Application.compile_env` 静态配置
- `configure_agent` BDD 指令仅在测试时设置参数

**实现要点**：
- 新增 `Gong.Settings`：ETS + 文件持久化
- 支持全局（`~/.gong/settings.json`）+ 项目级（`{workspace}/.gong/settings.json`）
- 运行时读写，项目级覆盖全局

**BDD 场景**（需新增）：
- `BDD-SETTINGS-001`：读取默认设置 — 无配置文件时返回默认值
- `BDD-SETTINGS-002`：项目级覆盖 — 全局 model=A，项目级 model=B → 生效 B
- `BDD-SETTINGS-003`：运行时修改 — 修改 setting 后立即生效

---

### P2：Resource 发现（3 个场景）

**架构出处**：Section 2.2（system prompt 构建中注入 context 文件）
**pi-mono 测试**：`resource-loader.test.ts` — 14 个用例（363 行），覆盖 skill/prompt/theme/extension 发现、覆盖、reload
**Gong 现状**：
- `Gong.Prompt` 硬编码系统提示词模板
- 无文件级 prompt 模板、skill 定义、context 文件自动发现

**实现要点**：
- 新增 `Gong.ResourceLoader`：扫描 `~/.gong/` + `{workspace}/.gong/`
- 支持文件类型：`prompts/*.md`、`skills/*.md`、`context/*.md`
- system prompt 构建时自动注入发现的 context 文件
- 支持 reload（文件变更后刷新）

**BDD 场景**（需新增）：
- `BDD-RESOURCE-001`：发现 context 文件 — workspace/.gong/context/rules.md → 注入 system prompt
- `BDD-RESOURCE-002`：全局 + 项目级合并 — 两级目录的资源合并，项目级优先
- `BDD-RESOURCE-003`：reload 刷新 — 修改文件后调用 reload → 新内容生效

---

### P2：分支摘要（2 个场景）

**架构出处**：Section 7（会话管理，分支摘要生成）
**pi-mono 测试**：`compaction.test.ts` 中 branch summary 相关 — 约 5 个用例
**Gong 现状**：
- Compaction 有摘要生成，但无分支摘要
- 需要 Session 树形分支（P1）先完成

**BDD 场景**（需新增）：
- `BDD-BRANCHSUM-001`：切换分支时生成摘要 — 离开分支 A → 自动生成 A 的摘要
- `BDD-BRANCHSUM-002`：摘要内容正确 — 摘要包含分支中的关键操作和结果

---

### P2：truncate 工具（2 个场景）

**架构出处**：无直接出处（pi-mono 设计选择：LLM 可调用 vs Gong 系统自动）
**pi-mono 测试**：`truncate-to-width.test.ts` — 6 个用例（81 行）
**Gong 现状**：
- `Gong.Truncate` 系统级自动截断，14 个 BDD 场景
- LLM 无法主动请求截断特定输出
- 设计决策：是否需要暴露给 LLM 待讨论

**BDD 场景**（需新增）：
- `BDD-TRUNCTOOL-001`：LLM 调用 truncate 工具 — 传入长文本 + max_lines → 返回截断结果
- `BDD-TRUNCTOOL-002`：truncate 与系统截断的交互 — 工具截断后系统不再重复截断

---

### P2：edit-diff 工具（3 个场景）

**架构出处**：Section A step 10（diff 生成：4 行上下文 unified diff）
**pi-mono 测试**：`tools.test.ts` — 42 个用例（638 行）中 diff 相关约 8 个
**Gong 现状**：
- Edit 使用字符串精确匹配 + 模糊匹配，22 个 BDD 场景
- 已有简单 diff 输出（在 edit 结果中）
- 无 unified diff 作为输入格式

**BDD 场景**（需新增）：
- `BDD-EDITDIFF-001`：unified diff 输入 — 传入 diff 格式 → 正确应用修改
- `BDD-EDITDIFF-002`：diff 行号偏移 — 修改位置与文件行号有偏移时仍能正确定位
- `BDD-EDITDIFF-003`：diff + 字符串替换共存 — 两种 edit 模式在同一 agent 会话中交替使用

---

### P2：path-utils 工具（2 个场景）

**架构出处**：Section A（路径扩展 macOS + NFS + Docker）
**pi-mono 测试**：`path-utils.test.ts` — 10 个用例（147 行），覆盖 ~ 扩展、Unicode 空格规范化、NFC/NFD、弯引号
**Gong 现状**：
- 各工具内部分别处理路径（Read/Write/Edit 各自有 `Path.expand`）
- 无统一的路径规范化工具
- macOS NFD 变体处理未覆盖

**BDD 场景**（需新增）：
- `BDD-PATHUTIL-001`：路径规范化 — ~、相对路径、. 和 .. 一致处理
- `BDD-PATHUTIL-002`：macOS NFD 变体 — NFD 编码的文件名 → 正确解析

---

## BDD 覆盖缺口汇总（Phase VII + Phase VIII）

### Phase VII（内部改进）

| 缺口 | 需新增场景 | 对应架构测试 |
|------|-----------|-------------|
| Steering 中断 | BDD-AGENT-031~032 | J.9 test 1.4 |
| Auto-retry | BDD-AGENT-033~035 | J.9 tests 4.3, 4.7, 5.1 |
| Auto-compaction | BDD-AGENT-036~037 | J.9 tests 4.3, 4.4 |
| tool_call/result 配对 | BDD-COMPACT-015~016 | J.9 tests 4.2, 4.6 |
| 结构化摘要 prompt | BDD-COMPACT-017~018 | Section 6.2 step 5 |
| 迭代摘要更新 | BDD-COMPACT-019~020 | Section 6.2 step 7 |
| Edit BOM/CRLF/Diff | BDD-EDIT-017~022 ✅ | J.1 tests 3.1-3.5, 5.3 |
| Edit 安全边界补全 | BDD-EDIT-023~026 ✅ | J.1 tests 4.2, 4.4, 4.5, 4.6 |
| Find .gitignore | BDD-FIND-008 | J.6 test 2.1 |
| Bash 截断/临时文件 | BDD-BASH-015~016 ✅ | J.2 tests 3.1, 3.2 |
| Bash Pi bug 回归 | BDD-BASH-017~021 ✅ | J.2 tests 4.1, 5.1-5.5 |
| **小计** | **29 个场景（全部已完成）** | |

### Phase VIII（Pi-mono 功能对齐）

| 缺口 | 优先级 | 需新增场景 | pi-mono 对应测试数 |
|------|--------|-----------|-------------------|
| 流式输出 | P0 | BDD-STREAM-001~008 | 110 |
| 多模型切换 | P0 | BDD-MODEL-001~006 | 38 |
| Session 分支 | P1 | BDD-SESSION-001~006 | 13 |
| Abort 信号 | P1 | BDD-ABORT-001~005 | 21 |
| Extension 系统 | P1 | BDD-EXTEND-001~006 | 45 |
| Follow-up 队列 | P2 | BDD-FOLLOWUP-001~002 | 1 |
| Settings 管理 | P2 | BDD-SETTINGS-001~003 | 10 |
| Resource 发现 | P2 | BDD-RESOURCE-001~003 | 14 |
| 分支摘要 | P2 | BDD-BRANCHSUM-001~002 | 5 |
| truncate 工具 | P2 | BDD-TRUNCTOOL-001~002 | 6 |
| edit-diff 工具 | P2 | BDD-EDITDIFF-001~003 | 8 |
| path-utils 工具 | P2 | BDD-PATHUTIL-001~002 | 10 |
| **小计** | | **48 个新场景** | **281** |

### 总计

| 范围 | 现有测试 | Phase VII | Phase VIII | 总计 |
|------|---------|-----------|-----------|------|
| BDD 场景数 | 244 | +21（Agent 集成 11 + Edit/Bash 缺口 9 + 1）✅ | +48 ✅ | **313** |
| ExUnit 测试 | 244 | **265** ✅ | +48 = **313** ✅ | **313** |
| 测试覆盖率 | 已实现功能 100% | 内部改进 + Bug 回归 + 工具安全 | Pi-mono 功能对齐 | 68% 模块覆盖 |

---

## 实施顺序与测试步骤

### 依赖关系图

```
Phase VII（先还测试债务）
│
├─ ① Pi Bug 回归 (038-041)
├─ ② Steering 集成 (031-032)         ← 依赖 ①
├─ ③ Auto-retry 集成 (033-035)       ← 依赖 ①
└─ ④ Auto-compaction 集成 (036-037)  ← 依赖 ①
      │
Phase VIII（功能对齐）
      │
├─ P0（必须）
│   ├─ ⑤ 流式输出 (STREAM-001~008)     ← 依赖 Phase VII 完成
│   └─ ⑥ 多模型切换 (MODEL-001~006)    ← 可与 ⑤ 并行
│
├─ P1（重要）
│   ├─ ⑦ Abort 信号 (ABORT-001~005)    ← 依赖 ⑤ 流式
│   ├─ ⑧ Session 分支 (SESSION-001~006) ← 独立，可与 ⑤⑥⑦ 并行
│   └─ ⑨ Extension 系统 (EXTEND-001~006) ← 独立，可并行
│
└─ P2（完善）
    ├─ ⑩ 分支摘要 (BRANCHSUM-001~002)   ← 依赖 ⑧
    ├─ ⑪ Follow-up 队列 (FOLLOWUP-001~002)
    ├─ ⑫ Settings (SETTINGS-001~003)
    ├─ ⑬ Resource 发现 (RESOURCE-001~003)
    └─ ⑭ 工具补全 (TRUNCTOOL + EDITDIFF + PATHUTIL)
```

### 分批交付计划

---

#### 第一批：Phase VII 收尾（11 + 9 个场景） ✅ 已完成

做完后所有现有功能有完整的集成级 BDD 覆盖。
**验收结果**：265 tests, 0 failures
- 11 个 Agent 集成场景（BDD-AGENT-031~041）：Steering/Retry/Compaction/Pi Bug
- 9 个工具缺口补全：BDD-EDIT-023~026（二进制保护/路径遍历/超大文件/并发）+ BDD-BASH-017~021（UTF-8/交互式超时/进程组杀死/SIGPIPE/截断计数）
- Edit 工具新增安全检查：二进制文件检测、路径遍历防护、10MB 文件大小限制

##### Step ① Pi Bug 回归（4 个场景） ✅

不需要新模块，验证现有代码行为是否正确。

**实现步骤**：
1. 在 `docs/bdd/agent_integration.dsl` 末尾追加 4 个场景（BDD-AGENT-038~041）
2. `bddc compile` 生成测试
3. `mix test test/bdd_generated/agent_integration_generated_test.exs` 运行

**具体实现**：

`BDD-AGENT-038`（并发竞态）：
- GIVEN：configure_agent + mock_llm_response（慢响应，sleep 模拟）
- WHEN：agent_chat（第一轮），**同时** agent_chat（第二轮）
- THEN：第二个请求被拒绝（返回 :busy 或排队）
- **代码改动**：MockLLM.run_chat 入口加锁（`Process.put(:gong_agent_busy, true)`），忙时返回 `{:error, :busy, agent}`
- **可能需要新 BDD 指令**：`agent_chat_concurrent` — 用 `Task.async` 同时发起两次 chat

`BDD-AGENT-039`（孤儿 tool_result）：
- GIVEN：configure_agent + mock 两个 tool_call 响应 + steering 在第一个 tool 后中断
- WHEN：agent_chat，第一个 tool 执行后 steering 中断跳过第二个
- THEN：下一轮 agent_chat_continue 不报错（孤儿 tool_result 已清理）
- **代码改动**：MockLLM.execute_pending_tools 中，被跳过的 tool 生成的 skip result 要正确回传给 ReAct 策略
- **依赖**：需要 ② Steering 集成先完成，或同时实现

`BDD-AGENT-040`（非数组 content）：
- GIVEN：configure_agent + mock_llm_response 返回 content 为纯字符串（不是 list）
- WHEN：agent_chat
- THEN：assert_no_crash + assert_agent_reply 正常
- **代码改动**：检查 MockLLM/LiveLLM 的 `build_llm_result_from_response` 是否能处理字符串 content
- **可能无需改代码**，Elixir 模式匹配天然兼容

`BDD-AGENT-041`（结果不错位）：
- GIVEN：configure_agent + create_temp_file a.txt/b.txt/c.txt + mock_llm_response 一次返回 3 个 tool_call
- WHEN：agent_chat prompt="读取三个文件"
- THEN：assert_tool_was_called tool="read_file" 3 次 + 每个结果对应正确文件内容
- **代码改动**：无（现有 execute_pending_tools 按 tool_call_id 回传，但需要验证）
- **可能需要新 BDD 指令**：`assert_tool_result_matches call_index=0 contains="Content A"`

**测试验证**：
```bash
bddc compile
mix test test/bdd_generated/agent_integration_generated_test.exs --trace
# 预期：30 个旧场景 + 4 个新场景全部通过
```

##### Step ② Steering 集成（2 个场景） ✅

让 Agent 循环在工具执行期间真正响应 steering 中断。

**实现步骤**：
1. 修改 `test/support/mock_llm.ex` 的 `execute_pending_tools`：每个 tool 执行后调用 `Gong.Steering.check/1`
2. 修改 `test/support/live_llm.ex` 同步改动
3. 在 `docs/bdd/agent_integration.dsl` 追加 2 个场景
4. 可能需要新 BDD 指令：`inject_steering_during_tool` — 在工具执行回调中注入 steering 消息

**具体实现**：

`BDD-AGENT-031`（中断跳过剩余工具）：
- GIVEN：configure_agent + mock 返回 3 个 tool_call + register steering 在第 1 个 tool 后注入
- WHEN：agent_chat
- THEN：第 1 个 tool 执行，第 2、3 个被跳过（结果含 "Skipped"）
- **代码改动**：
  ```elixir
  # mock_llm.ex — execute_pending_tools
  Enum.reduce(pending, {agent, steering_queue}, fn tc, {acc_agent, queue} ->
    case Gong.Steering.check(queue) do
      {nil, queue} ->
        # 正常执行工具
        ...
      {steering_msg, remaining_queue} ->
        # 跳过当前 tool，注入 skip result
        skip_result = Gong.Steering.skip_result(tc.name)
        ...
    end
  end)
  ```

`BDD-AGENT-032`（steering 消息下一轮处理）：
- GIVEN：同上 + mock 一个后续 LLM 响应（收到 skip 结果后的回复）
- WHEN：agent_chat
- THEN：LLM 收到跳过通知和 steering 消息，下一轮正常响应

**测试验证**：
```bash
bddc compile
mix test test/bdd_generated/agent_integration_generated_test.exs --trace
# 预期：34 个场景全部通过（30 旧 + 4 回归 + 2 新）
```

##### Step ③ Auto-retry 集成（3 个场景） ✅

LLM 调用失败时自动走 Retry 模块重试。

**实现步骤**：
1. 修改 `test/support/mock_llm.ex` 的 `drive_loop`：LLM 响应为错误时调用 `Gong.Retry.classify/1`
2. 分类为 `:transient` → 退避重试（最多 3 次）
3. 分类为 `:context_overflow` → 触发 compaction（见 ④）
4. 分类为 `:permanent` → 立即失败
5. 同步修改 `test/support/live_llm.ex`
6. 在 `docs/bdd/agent_integration.dsl` 追加 3 个场景

**具体实现**：

`BDD-AGENT-033`（429 重试不压缩）：
- GIVEN：configure_agent + mock 第一次返回 429 错误 + 第二次返回正常文本
- WHEN：agent_chat
- THEN：assert_agent_reply 正常 + assert_no_crash + **无** compaction 被触发
- **新 BDD 指令**：`assert_compaction_not_triggered` — 检查 telemetry 无 compaction 事件

`BDD-AGENT-034`（重试成功后继续）：
- GIVEN：configure_agent + mock 第一次超时 + 第二次返回 tool_call + 第三次返回文本
- WHEN：agent_chat
- THEN：tool 被执行 + 最终 reply 正确

`BDD-AGENT-035`（重试耗尽）：
- GIVEN：configure_agent + mock 连续 4 次返回 429
- WHEN：agent_chat
- THEN：assert_tool_error（或 last_error 非空）+ 错误信息含 "retry"

**代码改动**（mock_llm.ex 的 drive_loop）：
```elixir
defp drive_loop(agent, call_id, hooks, opts, responses, iteration, max_iter) do
  case pop_response(responses) do
    {:error_response, error_msg, rest} ->
      case Gong.Retry.classify(error_msg) do
        :transient ->
          retry_count = Keyword.get(opts, :retry_count, 0)
          if retry_count < 3 do
            delay = Gong.Retry.delay(retry_count)
            Process.sleep(delay)  # 测试中可以 mock 为 0
            drive_loop(agent, call_id, hooks,
              Keyword.put(opts, :retry_count, retry_count + 1),
              rest, iteration, max_iter)
          else
            {:error, "重试耗尽: #{error_msg}", agent}
          end
        :permanent ->
          {:error, error_msg, agent}
        :context_overflow ->
          # 见 Step ④
          ...
      end
    ...
  end
end
```

**测试验证**：
```bash
bddc compile
mix test test/bdd_generated/agent_integration_generated_test.exs --trace
# 预期：37 个场景全部通过
```

##### Step ④ Auto-compaction 集成（2 个场景） ✅

Agent 循环自动检测上下文溢出并触发压缩。

**实现步骤**：
1. 修改 MockLLM/LiveLLM 的 `drive_loop`：每轮结束后调用 `Gong.AutoCompaction.maybe_compact/3`
2. `:context_overflow` 错误分类也触发 compaction
3. 在 `docs/bdd/agent_integration.dsl` 追加 2 个场景

**具体实现**：

`BDD-AGENT-036`（上下文超限自动压缩）：
- GIVEN：configure_agent with context_window=2000 + 大量 mock 消息填充上下文
- WHEN：agent_chat（触发溢出检测）
- THEN：assert_telemetry_received event="gong.compaction.start" + 对话继续不崩溃

`BDD-AGENT-037`（压缩期间排队消息恢复）：
- GIVEN：同上 + 在 compaction 过程中注入 steering 消息
- WHEN：agent_chat
- THEN：compaction 完成后 steering 消息被处理，不丢失

**测试验证**：
```bash
bddc compile
mix test test/bdd_generated/agent_integration_generated_test.exs --trace
# 预期：39 个场景全部通过
mix test  # 全量回归
# 预期：244 + 11 + 9 = 265 个场景通过（实际验收结果：265 tests, 0 failures）
```

**第一批完成标准** ✅：
```bash
mix test --trace
# 265 tests, 0 failures (不含 E2E)
mix test --include e2e --trace
# 285 tests, 0 failures (含 E2E，需 DEEPSEEK_API_KEY)
```

---

#### 第二批：核心能力（14 个场景） ✅ 已完成

做完后 Gong 有流式输出 + 多模型，可以开始做 CLI/Web 前端。
**验收结果**：284 tests, 0 failures（265 + 19）

##### Step ⑤ 流式输出（8 个场景） ✅

**新文件**：
- `lib/gong/stream.ex` — 流式事件定义 + 推送机制
- `test/support/mock_stream.ex` — Mock 流式 LLM 响应

**实现步骤**：
1. 定义流式事件结构：
   ```elixir
   defmodule Gong.Stream.Event do
     @type t :: %__MODULE__{
       type: :text_start | :text_delta | :text_end |
             :tool_start | :tool_delta | :tool_end |
             :thinking_start | :thinking_delta | :thinking_end |
             :error,
       data: map()
     }
   end
   ```
2. 在 MockLLM 中增加 `stream_chat/4`：从 mock 队列按 chunk 推送事件
3. 在 LiveLLM 中增加 `stream_chat/4`：调用 `ReqLLM.stream_text/3`，逐 chunk 转换为事件
4. 新增 BDD 指令：
   - `mock_stream_response` — 注册分块的 mock 流式响应
   - `agent_stream_chat` — 使用流式模式对话
   - `agent_stream_chat_live` — E2E 流式
   - `assert_stream_event` — 断言收到指定类型的流式事件
   - `assert_stream_sequence` — 断言事件序列
5. 在 `docs/bdd/` 新建 `streaming.dsl`，写入 8 个场景
6. 注册新指令到 `lib/gong/bdd/instruction_registries/`

**场景细节**：

| 场景 | 关键 GIVEN | 关键 WHEN | 关键 THEN |
|------|-----------|-----------|-----------|
| STREAM-001 纯文本流 | mock_stream_response chunks=["Hello"," wor","ld"] | agent_stream_chat | assert_stream_sequence types="text_start,text_delta,text_delta,text_delta,text_end" + reply="Hello world" |
| STREAM-002 tool call 流 | mock_stream_response type=tool_call chunks=[name,args_part1,args_part2] | agent_stream_chat | assert_stream_event type="tool_start" + tool 被执行 |
| STREAM-003 流式中断 | mock_stream_response slow=true + inject_steering | agent_stream_chat | 流被中断 + partial 内容保留 |
| STREAM-004 空中断 | mock_stream_response + 立即 steering | agent_stream_chat | partial message 丢弃 |
| STREAM-005 事件序列 | mock_stream_response | agent_stream_chat | assert_stream_sequence 顺序正确 |
| STREAM-006 流式+Hook | mock_stream_response + register_hook InjectContext | agent_stream_chat | Hook 在流式前生效 + assert_no_crash |
| STREAM-007 流式超时 | mock_stream_response stall_after=2 | agent_stream_chat | assert_tool_error contains="timeout" |
| STREAM-008 E2E 流式 | check_e2e_provider + create_temp_file | agent_stream_chat_live | assert_stream_event type="text_delta" + reply 非空 |

**测试验证**：
```bash
bddc compile
mix test test/bdd_generated/streaming_generated_test.exs --trace
# 预期：8 个场景通过（STREAM-008 需要 DEEPSEEK_API_KEY，无 key 时跳过）
mix test  # 全量回归
# 预期：273 tests, 0 failures
```

##### Step ⑥ 多模型运行时切换（6 个场景） ✅

**新文件**：
- `lib/gong/model_registry.ex` — 模型注册 + 运行时切换

**实现步骤**：
1. 实现 `Gong.ModelRegistry`：
   ```elixir
   defmodule Gong.ModelRegistry do
     # ETS 表存储可用模型
     def register(name, provider_spec)     # 注册模型
     def switch(agent, model_name)         # 运行时切换
     def current(agent)                    # 查询当前模型
     def available()                       # 列出所有已注册模型
     def resolve_api_key(provider)         # 从环境变量读取 API Key
   end
   ```
2. 修改 `Gong.Agent` 支持动态 model（从 strategy state 读取而非硬编码）
3. 修改 LiveLLM 的 `call_real_llm/1`：从 ModelRegistry 读取当前模型
4. 新增 BDD 指令：
   - `register_model` — 注册一个模型到 Registry
   - `switch_model` — 运行时切换模型
   - `assert_model_used` — 断言使用了指定模型（通过 telemetry 或 mock 捕获）
5. 在 `docs/bdd/` 新建 `model_registry.dsl`，写入 6 个场景

**场景细节**：

| 场景 | 操作 | 验证 |
|------|------|------|
| MODEL-001 默认配置 | configure_agent model="deepseek:deepseek-chat" | agent 使用该模型 |
| MODEL-002 运行时切换 | 第一轮 model A → switch_model B → 第二轮 | 第二轮用 B |
| MODEL-003 无效模型回退 | configure_agent model="nonexistent" | 回退到默认模型 + 日志警告 |
| MODEL-004 API Key 缺失 | register_model 但不设环境变量 | 友好错误，不崩溃 |
| MODEL-005 多 Provider | register deepseek + openai | 按名选择正确 |
| MODEL-006 E2E 切换 | check_e2e_provider + agent_chat_live | 真实 API 响应格式正确 |

**测试验证**：
```bash
bddc compile
mix test test/bdd_generated/model_registry_generated_test.exs --trace
# 预期：6 个场景通过
mix test  # 全量回归
# 预期：279 tests, 0 failures
```

**第二批完成标准** ✅：
```bash
mix test --trace
# 284 tests, 0 failures
# 流式 + 多模型功能可用
```

---

#### 第三批：产品化（17 个场景） ✅ 已完成

⑦⑧⑨ 可并行开发（除 ⑦ 依赖 ⑤ 的流式 API）。
**验收结果**：296 tests, 0 failures（284 + 12）

##### Step ⑦ Abort 信号传播（5 个场景） ✅

**新文件**：
- `lib/gong/abort.ex` — Abort 信号管理

**实现步骤**：
1. 实现 `Gong.Abort`：
   ```elixir
   defmodule Gong.Abort do
     # 基于进程消息的 abort 信号
     def signal(agent_pid)           # 发送 abort
     def check!()                    # 检查是否 aborted（raise if so）
     def aborted?()                  # 非抛出检查
   end
   ```
2. 在 Agent 循环关键点插入 `Abort.check!()`：
   - 每个 tool 执行前
   - LLM 调用前
   - 流式每个 chunk 接收时
3. Bash 工具：abort 时调用已有的 `kill_process_tree`
4. 流式：abort 时关闭 HTTP 连接（ReqLLM 支持 `cancel/1`）
5. 新增 BDD 指令：
   - `send_abort` — 向 agent 发送 abort 信号
   - `send_abort_during_tool` — 在工具执行回调中发送 abort
   - `assert_aborted` — 断言 agent 返回 aborted 状态
6. 在 `docs/bdd/` 新建 `abort.dsl`，写入 5 个场景

**场景细节**：

| 场景 | 触发时机 | 预期行为 |
|------|---------|---------|
| ABORT-001 工具执行中 | bash sleep 10 时 abort | 进程被杀 + 返回 "aborted" |
| ABORT-002 多工具跳过 | 第 1 个 tool 后 abort | 剩余 2 个跳过 |
| ABORT-003 LLM 等待中 | mock slow LLM 时 abort | 返回 aborted 错误 |
| ABORT-004 abort 后恢复 | abort → 再发新 prompt | 正常响应 |
| ABORT-005 partial 保留 | 流式已收到部分内容时 abort | partial text 保留在上下文中 |

**测试验证**：
```bash
bddc compile
mix test test/bdd_generated/abort_generated_test.exs --trace
# 预期：5 个场景通过
```

##### Step ⑧ Session 树形分支（6 个场景） ✅

**修改文件**：
- `lib/gong/tape/store.ex` — 增加分支操作
- `lib/gong/tape/index.ex` — 增加 parent_anchor_id 字段

**实现步骤**：
1. Index 表增加 `parent_anchor_id` 列：
   ```sql
   ALTER TABLE anchors ADD COLUMN parent_anchor_id INTEGER REFERENCES anchors(seq);
   ```
2. Store 增加分支 API：
   ```elixir
   def branch_from(store, anchor_seq)    # 从指定 anchor 创建分支
   def navigate(store, anchor_seq)       # 切换到分支叶节点
   def branches(store, anchor_seq)       # 列出子分支
   def build_context_path(store)         # 沿分支路径回溯到根
   ```
3. 上下文构建时用 `build_context_path` 替代线性扫描
4. 新增 BDD 指令：
   - `tape_branch_from` — 从 anchor 创建分支
   - `tape_navigate` — 切换分支
   - `tape_list_branches` — 查询分支
   - `assert_branch_count` — 断言分支数量
   - `assert_context_path` — 断言上下文路径内容
5. 在 `docs/bdd/tape_storage.dsl` 末尾追加 6 个场景

**测试验证**：
```bash
bddc compile
mix test test/bdd_generated/tape_storage_generated_test.exs --trace
# 预期：40 个场景通过（34 旧 + 6 新）
```

##### Step ⑨ Extension 加载/发现（6 个场景） ✅

**新文件**：
- `lib/gong/extension/loader.ex` — 扫描和加载 .ex 文件
- `lib/gong/extension/runner.ex` — Extension 生命周期管理
- `lib/gong/extension.ex` — Extension behaviour 定义

**实现步骤**：
1. 定义 Extension behaviour（继承 Hook + 增加 tools/commands）：
   ```elixir
   defmodule Gong.Extension do
     @callback init(config :: map()) :: {:ok, state :: term()} | {:error, term()}
     @callback tools() :: [module()]                    # 可选
     @callback commands() :: [map()]                    # 可选
     @callback cleanup(state :: term()) :: :ok          # 可选
     # 继承所有 Gong.Hook 回调（可选实现）
   end
   ```
2. Loader：扫描目录 → `Code.compile_file/1` → 验证 behaviour → 返回模块列表
3. Runner：init 所有 Extension → 注入 Hook 列表和工具列表 → Agent 运行 → cleanup
4. 错误隔离：`try/catch` 包裹每个 Extension 操作
5. 新增 BDD 指令：
   - `create_extension_file` — 在临时目录的 extensions/ 下创建 .ex 文件
   - `load_extensions` — 触发 Loader 扫描加载
   - `assert_extension_loaded` — 断言 Extension 被发现
   - `assert_extension_tool_available` — 断言自定义工具可用
6. 在 `docs/bdd/` 新建 `extension.dsl`，写入 6 个场景

**测试验证**：
```bash
bddc compile
mix test test/bdd_generated/extension_generated_test.exs --trace
# 预期：6 个场景通过
mix test  # 全量回归
# 预期：296 tests, 0 failures
```

**第三批完成标准** ✅：
```bash
mix test --trace
# 296 tests, 0 failures
# Abort + Session 分支 + Extension 全部可用
```

---

#### 第四批：完善（17 个场景） ✅ 已完成

各模块独立，无严格顺序。分支摘要（⑩）依赖 Session 分支（⑧）。
**验收结果**：313 tests, 0 failures（296 + 17）

##### Step ⑩ 分支摘要（2 个场景） ✅

**前置**：Step ⑧ 完成

**修改文件**：`lib/gong/tape/store.ex` + `lib/gong/compaction.ex`

**实现步骤**：
1. Store 增加 `generate_branch_summary/2`：离开分支时用 LLM 生成摘要
2. 摘要存为特殊 entry（kind: :branch_summary）
3. 新增 BDD 指令：`tape_switch_branch`、`assert_branch_summary_exists`
4. 在 `docs/bdd/tape_storage.dsl` 追加 2 个场景

**测试验证**：
```bash
bddc compile
mix test test/bdd_generated/tape_storage_generated_test.exs --trace
# 预期：42 个场景通过
```

##### Step ⑪ Follow-up 消息队列（2 个场景） ✅

**修改文件**：`lib/gong/steering.ex` + MockLLM/LiveLLM

**实现步骤**：
1. Steering 增加 `:follow_up` 类型消息，与 `:steering` 区分
2. Agent 循环完成后检查 follow_up 队列，有则自动继续下一轮
3. 新增 BDD 指令：`push_follow_up`、`assert_follow_up_processed`
4. 在 `docs/bdd/steering.dsl` 追加 2 个场景

**测试验证**：
```bash
bddc compile
mix test test/bdd_generated/steering_generated_test.exs --trace
# 预期：4 个场景通过（2 旧 + 2 新）
```

##### Step ⑫ Settings 管理（3 个场景） ✅

**新文件**：`lib/gong/settings.ex`

**实现步骤**：
1. ETS 表 + JSON 文件持久化
2. 全局（`~/.gong/settings.json`）+ 项目级（`{workspace}/.gong/settings.json`），项目级覆盖全局
3. 新增 BDD 指令：`create_settings_file`、`read_setting`、`write_setting`、`assert_setting_value`
4. 在 `docs/bdd/` 新建 `settings.dsl`，写入 3 个场景

**测试验证**：
```bash
bddc compile
mix test test/bdd_generated/settings_generated_test.exs --trace
# 预期：3 个场景通过
```

##### Step ⑬ Resource 发现（3 个场景） ✅

**新文件**：`lib/gong/resource_loader.ex`

**实现步骤**：
1. 扫描 `~/.gong/` + `{workspace}/.gong/` 下的 `prompts/`、`skills/`、`context/` 目录
2. 读取 `.md` 文件内容，注入到 system prompt
3. 新增 BDD 指令：`create_resource_file`、`load_resources`、`assert_system_prompt_contains`
4. 在 `docs/bdd/` 新建 `resource_loader.dsl`，写入 3 个场景

**测试验证**：
```bash
bddc compile
mix test test/bdd_generated/resource_loader_generated_test.exs --trace
# 预期：3 个场景通过
```

##### Step ⑭ 工具补全（7 个场景） ✅

3 个子任务，独立实施：

**⑭a truncate 工具（2 个场景）**：
- 新增 `Gong.Tools.Truncate` Action 模块（暴露给 LLM 调用）
- 复用 `Gong.Truncate` 核心逻辑
- 在 `docs/bdd/truncate_system.dsl` 追加 2 个场景

**⑭b edit-diff 工具（3 个场景）**：
- 修改 `Gong.Tools.Edit`：增加 `mode: "diff"` 参数，接受 unified diff 格式输入
- 在 `docs/bdd/edit_action.dsl` 追加 3 个场景

**⑭c path-utils（2 个场景）**：
- 新增 `Gong.Tools.PathUtils` 或在现有工具中抽取共享的 `Gong.PathUtils` 模块
- 统一 ~、相对路径、NFD 处理
- 在 `docs/bdd/` 新建 `path_utils.dsl`，写入 2 个场景

**测试验证**：
```bash
bddc compile
mix test --trace
# 预期：315 tests, 0 failures（不含 E2E）
```

**第四批完成标准** ✅：
```bash
mix test --trace
# 313 tests, 0 failures（全部 BDD 场景通过，不含 E2E）
```

---

## 里程碑检查清单

| 里程碑 | 场景数 | 核心交付物 | 验收命令 | 状态 |
|--------|--------|-----------|---------|------|
| Phase VII 完成 | 244 + 11 + 9 = **265** | 所有现有功能有集成级 BDD 覆盖 + Edit/Bash 缺口清零 | `mix test` 265 pass | ✅ |
| P0 完成 | 265 + 19 = **284** | 流式输出 + 多模型切换 + Abort | `mix test` 284 pass | ✅ |
| P1 完成 | 284 + 12 = **296** | Session 分支 + Extension | `mix test` 296 pass | ✅ |
| P2 完成 | 296 + 17 = **313** | 全部功能对齐（不含 E2E） | `mix test` 313 pass | ✅ |
| E2E 全量 | 313 + ~31 = **~344** | 含真实 LLM E2E | `mix test --include e2e` ~344 pass | 待实施 |

---

## Phase IX: Gong vs Pi 功能对比 & BDD 覆盖差距分析

> 基于 2026-02-14 对 pi-mono 源码的全面对比。

### 功能对比矩阵

| 功能领域 | Pi (TypeScript) | Gong (Elixir) | 对齐度 | 说明 |
|---------|----------------|---------------|--------|------|
| **工具** | bash/read/write/edit/grep/find/ls | 相同 7 个 | ✅ 对齐 | |
| **Agent 循环** | event-driven + streaming | ReAct loop + MockLLM | ✅ 对齐 | |
| **流式输出** | 原生 streaming + partial tool results | Stream.Event 结构体 | ⚠️ 部分 | Gong 缺工具级流式（partial results） |
| **Abort** | AbortSignal 传播 | 进程字典 check point | ✅ 对齐 | |
| **Steering** | 中断 + follow_up 队列 | 已实现 | ✅ 对齐 | |
| **Session 持久化** | JSONL + tree navigation + fork | Tape JSONL + SQLite + branch | ✅ 对齐 | |
| **上下文压缩** | 自动摘要，保留最近 20% | Compaction 模块 | ✅ 对齐 | |
| **Hook 系统** | 25+ event types, cancelable | pipe/gate/special hooks | ⚠️ 部分 | Pi 事件种类多 3x |
| **Extension** | TS/JS 动态加载, tool/command/UI 注册 | .ex 动态编译, tool/hook/command | ⚠️ 部分 | Pi 更成熟（UI 替换、Widget） |
| **Settings** | JSON 持久化 + UI editor | ETS + JSON | ✅ 基础对齐 | Pi 有设置 UI |
| **Resource** | skills/prompts/themes/extensions 多级 | .gong/context/ .md 加载 | ⚠️ 部分 | Pi 支持 4 类资源 |
| **Model 管理** | 20+ providers, 200+ models, OAuth | ETS registry, 单 provider | ❌ 差距大 | **最大差距** |
| **Thinking 预算** | 6 级 thinking level 控制 | 无 | ❌ 缺失 | |
| **Provider OAuth** | Anthropic/Google/GitHub Copilot OAuth | 无 | ❌ 缺失 | |
| **Cross-provider** | 上下文跨 provider 保持 | 无 | ❌ 缺失 | |
| **RPC 模式** | JSON-RPC stdin/stdout 进程集成 | 无 | ❌ 缺失 | 嵌入式使用需求 |
| **TUI/Web UI** | TUI 框架 + React 组件 + Artifacts | 无 | — | 不在当前范围 |
| **Retry** | continue() + error report to LLM | 自动重试 429 | ✅ 对齐 | |
| **Truncation** | head/tail + 系统截断 | 相同策略 | ✅ 对齐 | |
| **Prompt 模板** | 可扩展 /templatename | 无 | ❌ 缺失 | |
| **Command 注册** | Extension 注册自定义命令 | 基础（Extension.commands） | ⚠️ 部分 | |
| **Cost 追踪** | 每次调用 token/cost 统计 | 无 | ❌ 缺失 | |
| **键盘快捷键** | Keybindings Manager | 无 | — | TUI 层功能 |

**核心功能对齐率：~70%**

### 功能差距分级

#### ❌ 重大差距（影响产品定位）

1. **多 Provider 支持**
   - Pi: 20+ providers, 200+ models, 统一 streaming 接口
   - Gong: 仅 DeepSeek，硬编码 provider
   - **影响**: 无法切换到 Claude/GPT/Gemini，限制使用场景
   - **工作量**: 新建 `lib/gong/providers/` 体系，~15 场景

2. **Thinking/Reasoning 预算**
   - Pi: 6 级 thinking level（off → xhigh），跨 provider 统一接口
   - Gong: 完全没有
   - **影响**: 无法利用 Claude/GPT 的深度推理能力
   - **工作量**: 新建模块 + ~5 场景

3. **Provider OAuth**
   - Pi: Anthropic/Google/GitHub Copilot OAuth 流程
   - Gong: 仅环境变量 API Key
   - **影响**: 无法对接需要 OAuth 的 provider
   - **工作量**: 新建 auth 模块 + ~4 场景

4. **Cost/Token 追踪**
   - Pi: 每次调用统计 token、cost、cache hit
   - Gong: 无
   - **影响**: 无法监控使用成本
   - **工作量**: ~4 场景

#### ⚠️ 中等差距（影响扩展性）

5. **Extension 事件体系**
   - Pi: 25+ 事件类型，含 cancelable、UI 替换、Widget
   - Gong: 基础 tool/hook/command，6 个场景
   - **补充**: +5~8 场景覆盖事件触发链、多 hook 冲突、cancelable

6. **Resource 多级发现**
   - Pi: skills/prompts/themes/extensions 四类
   - Gong: 仅 context/ 下 .md
   - **补充**: +3~4 场景覆盖多类资源

7. **Prompt 模板系统**
   - Pi: /templatename 可扩展提示模板
   - Gong: 无
   - **工作量**: 新建模块 + ~3 场景

8. **RPC 模式**
   - Pi: JSON-RPC stdin/stdout
   - Gong: 无
   - **影响**: 无法嵌入其他进程
   - **工作量**: 新建模块 + ~5 场景

### BDD 覆盖率现状

#### 按分类统计

| 分类 | DSL 文件数 | 场景数 | 模块覆盖率 |
|------|-----------|--------|-----------|
| 工具 (Tool) | 9 | 109 | 8/8 = 100% |
| Agent 核心 | 5 | 63 | 6/6 = 100% |
| 存储/压缩 | 5 | 65 | 5/7 = 71% |
| 扩展/插件 | 4 | 38 | 4/8 = 50% |
| 基础设施 | 0 | 0 | 0/5 = 0% |

**总计: 313 scenarios, 26 DSL, 23/34 模块直接覆盖 (68%)**

#### 已充分覆盖（无需补充）

- 7 个工具：read(20) + edit(26) + bash(21) + write(9) + grep(11) + find(8) + ls(7) = 102
- Agent 集成：41 场景（含 E2E、Hook、Steering、Retry、Compaction）
- Tape 存储：34 + 6 session + 2 branch = 42
- Compaction：22 + 3 auto = 25
- Hook 系统：23

#### 已覆盖但偏薄

| 模块 | 当前场景 | 建议补充 | 缺少内容 |
|------|---------|---------|---------|
| Stream | 8 | +2~3 | 工具级流式、多 chunk 拼接边界 |
| Extension | 6 | +3~4 | Runner 生命周期、事件触发链、多 hook 冲突 |
| Model Registry | 6 | +2 | Provider 降级链、并发切换 |
| Abort | 5 | +1~2 | 嵌套 abort（流式+工具同时） |
| Settings | 3 | +2 | 全局/项目合并优先级实际验证、类型校验 |
| Resource | 3 | +2 | 多类资源发现、大文件截断 |

#### 完全未覆盖

| 模块 | 重要性 | 建议场景数 | 缺少原因 |
|------|--------|----------|---------|
| `prompt.ex` | **P0** | 5~8 | 系统提示构建、摘要提示模板、上下文格式化 |
| `compaction/lock.ex` | **P0** | 3~4 | 并发锁竞争、死锁防护、超时释放 |
| `compaction/token_estimator.ex` | P1 | 2~3 | token 估算精度、边界值 |
| `providers/deepseek.ex` | P1 | 3~4 | API 配置、错误处理、响应格式 |
| `tape/file_store.ex` | P1 | 2~3 | 文件损坏恢复、并发写入 |
| `tape/entry.ex` | P2 | 1~2 | 序列化边界值 |
| `application.ex` | P2 | 2~3 | Supervisor 启动顺序 |

### BDD 补充计划

#### P0 — BDD 深度补全（+12~16 场景）

不涉及新功能，仅补全现有模块的测试盲区：

| DSL 文件 | 新增场景 | 覆盖内容 |
|---------|---------|---------|
| `prompt_engineering.dsl`（新建） | 5~8 | 摘要提示生成、compaction update/create 逻辑、消息格式化 |
| `compaction.dsl`（追加） | 3~4 | Lock 并发、token 估算、死锁防护 |
| `stream_integration.dsl`（追加） | 2~3 | 工具级流式、chunk 边界 |
| `extension.dsl`（追加） | 2~3 | Runner 全生命周期、多 Extension 冲突 |

**完成后: ~325~329 tests**

#### P1 — 功能差距填补（+20~30 场景）

对齐 Pi 的核心功能差距：

| 功能 | DSL 文件 | 场景数 | 新模块 |
|------|---------|--------|--------|
| 多 Provider 注册 | `provider.dsl`（新建） | 8~12 | `lib/gong/providers/*.ex` |
| Thinking 预算 | `thinking.dsl`（新建） | 4~6 | `lib/gong/thinking.ex` |
| Cost/Token 追踪 | `cost_tracking.dsl`（新建） | 3~4 | `lib/gong/cost_tracker.ex` |
| Prompt 模板 | `prompt_template.dsl`（新建） | 3~4 | `lib/gong/prompt_template.ex` |
| RPC 模式 | `rpc.dsl`（新建） | 4~6 | `lib/gong/rpc/` |

**完成后: ~350~360 tests**

#### P2 — 生态完善（+10~15 场景）

| 功能 | 场景数 | 备注 |
|------|--------|------|
| Provider OAuth | 3~4 | 需要真实 OAuth 流程 mock |
| Cross-provider handoff | 2~3 | 上下文跨 provider 保持 |
| 多级 Resource | 3~4 | skills/prompts/themes 分类 |
| Command 注册 | 2~3 | Extension 自定义命令执行 |

**完成后: ~365~375 tests**

### 总结

```
Phase VIII 实施完成    : 313 tests ✅
  ├─ 工具层           : 102 场景, 覆盖率 100%
  ├─ Agent 核心       : 63 场景, 覆盖率 100%
  ├─ 存储/压缩        : 65 场景, 覆盖率 71%
  ├─ 扩展/插件        : 38 场景, 覆盖率 50%
  └─ 基础设施         : 0 场景, 覆盖率 0%

与 Pi 对齐度          : ~70%
  ├─ 已对齐           : 工具、Agent循环、Abort、Steering、Session、Compaction、Retry
  ├─ 部分对齐         : Stream、Extension、Settings、Resource
  └─ 重大差距         : 多Provider、Thinking预算、OAuth、Cost追踪、RPC

BDD 下一步优先级      :
  P0 (+12~16 场景)    : prompt.ex 和 compaction/lock.ex 盲区补全
  P1 (+20~30 场景)    : 多 Provider + Thinking + Cost 功能对齐
  P2 (+10~15 场景)    : OAuth + Cross-provider + 生态完善
```
