# Gong (工) 实施计划

## 概述

本文档描述 Gong 项目从骨架到可用的完整实施路径。按依赖关系从底向上分 6 个阶段，每个阶段结束都有可验证的交付物。

### 依赖关系

```
工具 Actions (阶段一)
    ↓
截断系统 (阶段二)            Tape 存储 (阶段五) ←— 可与阶段三并行
    ↓                            ↓
Agent 循环 (阶段三)  ←———→  压缩 (阶段六上)
    ↓
Hook 系统 (阶段四)
    ↓
ZCPG 集成 (阶段六下)
```

### 测试基准

文档 `architecture.md` 第 J 节定义了 167 个必做 BDD 测试（含 20 个 Pi bug 回归 + 18 个 Hook 系统 + 8 个压缩系统 + 13 个参数校验与健壮性）+ 22 个留位测试。每个阶段实现完成后，对应的测试必须全部通过。

---

## 阶段一：7 个工具 Action

**目标**：所有工具 Action 的 `run/2` 实现完整功能，通过对应的 BDD 测试。

**前置条件**：无（纯函数式，不依赖 LLM 和外部服务）

### 实现顺序

按复杂度从低到高排列，每个工具做完立即写测试：

#### 1.1 read（文件读取）

- 对应模块：`Gong.Tools.Read`
- 对应测试：J.3 节，17 个用例
- 核心逻辑：
  - `File.stream!/1` 按行读取
  - `offset` + `limit` 分页
  - 行号前缀格式：`"     {n}\t{line}"`
  - 长行截断（超过 2000 字符的行截断并标记）
  - 文件不存在返回错误信息而非崩溃
- 边界情况：
  - 空文件返回空内容提示
  - 二进制文件检测（读前 8KB 检查 `\0` 字节）
  - offset 超出文件行数 → 返回空
  - 路径穿越校验（`../` 不能逃出工作区）

#### 1.2 ls（目录列表）

- 对应模块：`Gong.Tools.Ls`
- 对应测试：J.7 节，6 个用例
- 核心逻辑：
  - `File.ls!/1` + `File.stat/1` 获取元信息
  - 返回文件名、大小、类型（文件/目录/符号链接）
  - 结果按类型排序：目录优先，文件其次
- 边界情况：
  - 目录不存在 → 错误信息
  - 对文件路径调用 ls → 错误信息
  - 空目录 → 空列表
  - 大目录（>1000 条目）→ 截断并提示

#### 1.3 find（文件查找）

- 对应模块：`Gong.Tools.Find`
- 对应测试：J.6 节，6 个用例
- 核心逻辑：
  - `Path.wildcard/2` 执行 glob 匹配
  - 排除模式过滤（默认排除 `.git/`、`node_modules/`、`_build/`、`deps/`）
  - 结果按修改时间排序
  - 结果数量限制（默认 200）
- 边界情况：
  - 无匹配 → 空列表 + 提示
  - 符号链接不追踪（避免循环）

#### 1.4 grep（内容搜索）

- 对应模块：`Gong.Tools.Grep`
- 对应测试：J.5 节，10 个用例
- 核心逻辑：
  - `Regex.compile/2` 编译模式
  - 遍历文件，按行匹配
  - 支持上下文行数（`-A`/`-B`/`-C` 语义）
  - 输出模式：`content`（显示匹配行）、`files_with_matches`（只显示文件名）、`count`（显示计数）
  - glob 过滤搜索范围
- 边界情况：
  - 无效正则 → 友好错误信息
  - 二进制文件跳过
  - 结果过多 → 截断
  - 多文件匹配时按文件分组输出

#### 1.5 write（文件写入）

- 对应模块：`Gong.Tools.Write`
- 对应测试：J.4 节，7 个用例
- 核心逻辑：
  - `File.mkdir_p/1` 自动创建父目录
  - `File.write/3` 覆盖写入
  - 返回写入字节数
- 边界情况：
  - 路径穿越校验
  - 写入空字符串 → 创建空文件
  - 权限不足 → 错误信息
  - 写入到只读路径 → 错误信息

#### 1.6 edit（文件编辑）

- 对应模块：`Gong.Tools.Edit`
- 对应测试：J.1 节，23 个用例（最多）
- 核心逻辑：
  - 读文件 → 查找 `old_string` → 替换 → 写回
  - **唯一性校验**：`old_string` 在文件中必须恰好出现一次（除非 `replace_all: true`）
  - 多次匹配时报错并显示各匹配的行号
  - 零匹配时报错并提供模糊匹配建议
  - 保持原始换行符（CRLF 或 LF）
- 边界情况：
  - `old_string == new_string` → 报错，不做无意义替换
  - BOM 头处理（UTF-8 BOM 0xEF 0xBB 0xBF）
  - 包含正则特殊字符的字符串 → 精确匹配，不做正则
  - 路径穿越校验
  - `replace_all: true` 时返回替换次数

#### 1.7 bash（命令执行）

- 对应模块：`Gong.Tools.Bash`
- 对应测试：J.2 节，14 个用例
- 核心逻辑：
  - `System.cmd("bash", ["-c", command], opts)` 执行命令
  - 或用 `Port.open/2` 做更细粒度控制
  - 超时控制：`Task.async` + `Task.yield` + `Task.shutdown`
  - stdout 和 stderr 分离捕获
  - 输出超长时自动调用 `Gong.Truncate`
  - 工作目录设置（`cd: working_dir`）
- 边界情况：
  - 命令不存在 → exit_code 127 + 错误信息
  - 超时 → 杀进程 + 超时提示
  - 命令被信号终止 → 报告信号类型
  - 环境变量继承当前进程环境
  - 空命令 → 报错

### 阶段一交付物

- 7 个 Action 模块全部实现
- 101 个 BDD 测试通过（J.1 到 J.7 合计：26+21+20+9+11+7+7，含 11 个 Pi bug 回归 + 7 个参数校验与安全）
- 每个 Action 可以独立通过 `Jido.Action.run/2` 调用

---

## 阶段二：截断系统

**目标**：完善 `Gong.Truncate`，与工具输出对接。

**前置条件**：阶段一完成（截断要对接工具输出）

### 实现内容

#### 2.1 完善三策略实现

- `truncate_head`：保留开头 N 字节，UTF-8 安全截断
- `truncate_tail`：保留末尾 N 字节，UTF-8 安全截断
- `truncate_line`：保留头尾各 N 行，中间省略

当前骨架已有基础实现，需要补充：
- 空字符串输入 → `{"", false}`
- 恰好等于阈值 → 不截断
- off-by-one 边界测试

#### 2.2 工具输出对接

在 Agent 层面（不是工具内部）添加统一的截断中间件：

```elixir
defp maybe_truncate(result, opts) do
  max = Keyword.get(opts, :max_output_bytes, 30_000)
  case result do
    {:ok, %{content: content}} when byte_size(content) > max ->
      {truncated, true} = Gong.Truncate.truncate(content, :tail, max_bytes: max)
      {:ok, %{result | content: truncated}}
    other -> other
  end
end
```

### 阶段二交付物

- 截断系统 14 个测试通过（J.8 节，含 2 个 Pi bug 回归）
- 工具 + 截断合计 115 个测试通过

---

## 阶段三：Agent 循环

**目标**：LLM 调用 + 工具执行形成完整的 agent loop。

**前置条件**：阶段一、二完成

**外部依赖**：需要 LLM API key（Anthropic 或 OpenAI）

### 实现内容

#### 3.1 工具注册与 schema 转换

jido_ai 的 `ToolAdapter` 自动把 Jido Action 转成 LLM 的 tool schema：

```elixir
# Jido Action 的 schema 定义
schema: [
  file_path: [type: :string, required: true, doc: "文件绝对路径"],
  offset: [type: :non_neg_integer, default: 0, doc: "起始行号"]
]

# ↓ 自动转换为 ↓

# LLM tool_call 的 JSON Schema
%{
  "name" => "read_file",
  "description" => "读取文件内容，支持分页",
  "input_schema" => %{
    "type" => "object",
    "properties" => %{
      "file_path" => %{"type" => "string", "description" => "文件绝对路径"},
      "offset" => %{"type" => "integer", "description" => "起始行号"}
    },
    "required" => ["file_path"]
  }
}
```

需要验证 7 个 Action 的 schema 都能正确转换。

#### 3.2 Agent 循环实现

新建 `Gong.AgentLoop` 模块，核心流程：

```
用户消息 → 拼装上下文（系统提示 + 历史 + 工具列表）
    → 调 LLM（ReqLLM）
    → 解析响应
    → 如果有 tool_call → 执行对应 Action → 结果回传 → 继续循环
    → 如果是纯文本 → 返回给用户
    → 如果请求结束 → 退出循环
```

利用 jido_ai 的 `ReAct` 策略，不需要手写循环状态机：

```elixir
# jido_ai 已经封装了 ReAct 循环
Jido.AI.Agent.run(agent, signal, strategy: :react)
```

需要确认 `ReAct` 策略的以下行为：
- 最大循环次数限制（防止无限 tool_call）
- tool_call 失败时的错误恢复
- 多个 tool_call 的并行执行（Anthropic 支持）

#### 3.3 系统提示词

新建 `Gong.Prompt` 模块：

```elixir
defmodule Gong.Prompt do
  def system_prompt(workspace) do
    """
    你是一个通用 Agent，工作目录是 #{workspace}。
    使用提供的工具完成用户的任务。
    ...
    """
  end
end
```

系统提示词从 `Gong.Agent` 的 schema 中的 `system_prompt` 字段注入，支持用户自定义覆盖。

#### 3.4 流式输出

LLM 的响应支持 SSE 流式输出：

```elixir
ReqLLM.chat(model, messages, tools: tools, stream: true)
|> Stream.each(fn chunk -> send(caller, {:chunk, chunk}) end)
```

这是 ZCPG 集成的关键——ZCPG 的 SSE client 需要实时接收 token。

### 阶段三交付物

- `Gong.AgentLoop` 模块实现
- `Gong.Prompt` 模块实现
- 26 个集成测试通过（J.9 节，含 7 个 Pi bug 回归 + 6 个错误恢复与健壮性）
- 可以在 IEx 中手动跑完整的 agent 对话：

```elixir
iex> {:ok, agent} = Gong.AgentLoop.start(workspace: "/tmp/test")
iex> Gong.AgentLoop.chat(agent, "读一下 mix.exs 文件")
# → LLM 调 read_file → 返回文件内容 → LLM 生成总结
```

---

## 阶段四：Hook 系统

**目标**：实现事件拦截与数据变换基础设施，在工具执行、LLM 调用、会话操作等关键节点插入用户自定义逻辑。

**前置条件**：阶段三完成（Hook 的集成点在 Agent 循环中）

### 实现内容

#### 4.1 Hook Behaviour 定义

新建 `Gong.Hook` behaviour，定义 3 类回调：

```elixir
defmodule Gong.Hook do
  @doc "Gate 型：拦截操作，返回 :ok 放行或 {:block, reason} 阻止"
  @callback before_tool_call(tool :: atom(), params :: map()) ::
    :ok | {:block, String.t()}
  @callback before_session_op(op :: atom(), meta :: map()) ::
    :ok | :cancel

  @doc "Pipe 型：变换数据流，返回修改后的数据"
  @callback on_tool_result(tool :: atom(), result :: map()) :: map()
  @callback on_context(messages :: [map()]) :: [map()]
  @callback on_input(text :: String.t(), images :: [map()]) ::
    {:transform, String.t(), [map()]} | :passthrough | :handled

  @doc "Notify 型：观察事件，通过 :telemetry 广播"
  @callback on_before_agent(prompt :: String.t(), system :: String.t()) ::
    {String.t(), String.t(), [map()]}

  @optional_callbacks [before_tool_call: 2, before_session_op: 2,
    on_tool_result: 2, on_context: 1, on_input: 2, on_before_agent: 2]
end
```

#### 4.2 HookRunner 实现

新建 `Gong.HookRunner`，两个核心函数：

- **`pipe/3`**：Enum.reduce 链式调用，每个 hook 变换数据后传给下一个
- **`gate/2`**：Enum.reduce_while 链式调用，任一 hook 返回 block 则终止

错误隔离：单个 hook 异常不影响其他 hook，通过 try/rescue 捕获并发 telemetry 事件。

#### 4.3 Agent 循环集成

在 `Gong.AgentLoop` 的 5 个关键节点插入 hook 调用：

1. 用户输入进入前 → `on_input`
2. 构建上下文时 → `on_context`
3. 调 LLM 前 → `on_before_agent`
4. 工具执行前 → `before_tool_call`（gate）
5. 工具执行后 → `on_tool_result`（pipe）

#### 4.4 Telemetry 事件

注册标准 telemetry 事件供外部监控：

- `[:gong, :tool, :start]` / `[:gong, :tool, :stop]`
- `[:gong, :llm, :start]` / `[:gong, :llm, :stop]`
- `[:gong, :hook, :error]`

### 阶段四交付物

- `Gong.Hook` behaviour 模块
- `Gong.HookRunner` 实现模块
- Agent 循环 5 个集成点改造
- 18 个 Hook 系统 BDD 测试通过（J.10 节）
- 累计 159 个必做测试通过

---

## 阶段五：Tape 存储

**目标**：实现文件夹 + SQLite 索引的会话存储。

**前置条件**：无（独立模块，可与阶段三并行开发）

**注意**：此阶段不在 146 个必做测试范围内，需要额外编写测试。

### 实现内容

#### 5.1 SQLite schema 初始化

```elixir
defp init_db(db_path) do
  {:ok, conn} = Exqlite.Sqlite3.open(db_path)

  Exqlite.Sqlite3.execute(conn, """
    CREATE TABLE IF NOT EXISTS entries (
      id          INTEGER PRIMARY KEY AUTOINCREMENT,
      kind        TEXT NOT NULL,
      anchor_name TEXT NOT NULL,
      anchor_seq  INTEGER NOT NULL,
      file_path   TEXT NOT NULL,
      line_offset INTEGER,
      created_at  TEXT NOT NULL,
      summary     TEXT
    )
  """)

  # 建索引...
  # 建 FTS5 虚拟表...
end
```

或者用 Ecto + ecto_sqlite3 做 migration（更规范但更重）。

**决策点**：直接用 Exqlite 还是走 Ecto？
- Exqlite 直接 SQL：轻量，适合嵌入式场景，代码更少
- Ecto migration：规范，有 schema 版本管理，但引入 Repo 概念

建议先用 Exqlite 直接写，后续需要再抽 Ecto。

#### 5.2 核心操作实现

按顺序：

1. **`init/1`** — 创建 `anchors/` 目录 + `index.db` + 默认 anchor `001_session-start`
2. **`append/3`** — 写 JSONL 文件 + INSERT SQLite，用事务包裹
3. **`handoff/3`** — 创建新 anchor 目录 + INSERT anchor 记录
4. **`between_anchors/3`** — SQL 范围查询 → 定位文件 → 读 JSONL
5. **`search/2`** — FTS5 全文搜索 → 定位文件 → 读完整条目
6. **`fork/1`** — SQLite savepoint + 临时目录
7. **`merge/2`** — 合并临时目录到主目录 + 合并 SQLite 记录

#### 5.3 一致性保证

双写的原子性问题：

```elixir
def append(store, anchor, entry) do
  # 先写文件（追加，低风险）
  :ok = write_jsonl(file_path, entry)

  # 再写数据库（事务）
  {:ok, _} = insert_index(store.db, entry_meta)

  # 如果数据库写入失败，文件多了一行但索引没有
  # → 下次启动时可以通过扫描文件修复索引（rebuild_index）
end
```

添加 `rebuild_index/1` 函数：扫描 anchors/ 目录重建 SQLite 索引。

### 阶段五交付物

- `Gong.Tape.Store` 完整实现
- 额外编写约 15-20 个 Tape 存储测试
- 可以通过 `Gong.Tape.Store.init/1` 创建工作区，追加和查询条目

---

## 阶段六：压缩 + ZCPG 集成

**目标**：上下文压缩可用，Gong 接入 ZCPG 替换 OpenCode。

**前置条件**：阶段三、四、五完成

### 6a. 上下文压缩

#### 实现内容

新建或完善 `Gong.Compaction`：

```elixir
def compact(messages, opts) do
  window = Keyword.get(opts, :window_size, 20)
  max_tokens = Keyword.get(opts, :max_tokens, 100_000)

  if estimate_tokens(messages) <= max_tokens do
    {messages, nil}
  else
    {old, recent} = Enum.split(messages, -window)
    summary = summarize(old)  # 调 LLM 生成摘要
    {[%{role: "system", content: summary} | recent], summary}
  end
end
```

核心逻辑：
- Token 估算：按字符数粗估（中文 1 字 ≈ 2 token，英文 1 word ≈ 1.3 token）
- 滑动窗口：保留最近 N 条完整消息
- 摘要生成：调 LLM 对旧消息生成结构化摘要
- 系统消息和 anchor 消息不参与压缩，始终保留

#### 与 Tape 配合

压缩触发时，同时在 Tape 中创建新 anchor：

```elixir
def compact_and_handoff(tape_store, messages, opts) do
  {compacted, summary} = compact(messages, opts)
  if summary do
    Gong.Tape.Store.handoff(tape_store, "compaction", %{summary: summary})
  end
  compacted
end
```

### 6b. ZCPG 集成

#### 当前 ZCPG 架构

ZCPG 通过 `Zcpg.AI.AgentClient` behaviour 调用外部 agent：

```elixir
# 当前实现：HTTP 调 OpenCode (127.0.0.1:4096)
defmodule Zcpg.AI.Adapters.OpenCode do
  @behaviour Zcpg.AI.AgentClient

  def create_session(opts), do: ...   # POST /sessions
  def call(session, agent, input, opts), do: ...  # POST /sessions/:id/chat
  def stream(session, agent, input, callback, opts), do: ...  # SSE
  def abort(session, reason), do: ...
end
```

#### 新适配器

在 ZCPG 项目中新建 `Zcpg.AI.Adapters.Gong`：

```elixir
defmodule Zcpg.AI.Adapters.Gong do
  @behaviour Zcpg.AI.AgentClient

  def create_session(opts) do
    # 不再 HTTP，直接在 BEAM 内启动 Gong agent 进程
    {:ok, pid} = DynamicSupervisor.start_child(
      Gong.SessionSupervisor,
      {Gong.AgentLoop, workspace: opts[:workspace]}
    )
    {:ok, %{pid: pid, session_id: inspect(pid)}}
  end

  def call(session, _agent, input, _opts) do
    Gong.AgentLoop.chat(session.pid, input)
  end

  def stream(session, _agent, input, callback, _opts) do
    Gong.AgentLoop.stream(session.pid, input, callback)
  end

  def abort(session, _reason) do
    Gong.AgentLoop.cancel(session.pid)
  end
end
```

#### 集成步骤

1. ZCPG 的 `mix.exs` 添加 `{:gong, path: "../gong"}` 依赖
2. 新建 `Zcpg.AI.Adapters.Gong` 模块
3. 配置切换：`config :zcpg, :agent_adapter, Zcpg.AI.Adapters.Gong`
4. 保留 OpenCode 适配器作为回退
5. 验证 4 个 agent 场景：kb-triage、kb-answer、rlm-planner、build

#### 配置示例

```elixir
# config/config.exs
config :zcpg, :agent_adapter, Zcpg.AI.Adapters.Gong

config :gong,
  model: "anthropic/claude-sonnet-4-5-20250929",
  api_key: System.get_env("ANTHROPIC_API_KEY")
```

### 阶段六交付物

- `Gong.Compaction` 完整实现
- 8 个压缩系统 BDD 测试通过（J.12 节）
- `Zcpg.AI.Adapters.Gong` 适配器
- ZCPG 可通过配置切换使用 Gong 或 OpenCode
- 端到端验证：ZCPG 页面发消息 → Gong agent 处理 → 流式返回

---

## 里程碑总结

| 阶段 | 交付物 | 累计测试 | 外部依赖 |
|------|--------|----------|----------|
| 一 | 7 个工具 Action 完整实现 | 101 | 无 |
| 二 | 截断系统 + 工具对接 | 115 | 无 |
| 三 | Agent 循环 + LLM 调用 | 141 | LLM API key |
| 四 | Hook 系统 | 159 | 无 |
| 五 | Tape 存储（文件夹 + SQLite） | ~176 | 无 |
| 六 | 压缩 + ZCPG 集成 | ~192 | LLM API key + ZCPG 项目 |

### 并行度

```
时间线 →

阶段一 ████████████
阶段二          ████
阶段三              ████████████
阶段四                          ████
阶段五          ████████████████████  ← 可与二、三、四并行
阶段六                              ████████
```

阶段五（Tape 存储）是完全独立的模块，可以在阶段二开始后随时并行推进。
阶段四（Hook 系统）依赖阶段三的 Agent 循环，因为 Hook 的集成点在循环中。

### 风险点

1. **jido_ai 的 ReAct 策略** — main 分支未发布到 hex，API 可能变动。应对：pin commit hash
2. **Elixir 版本** — jido_browser 和 yaml_elixir 要求 1.18，当前系统是 1.17.3。应对：升级 Elixir 或排除 jido_browser
3. **tool_call 格式兼容** — 不同 LLM 提供商的 tool_call 格式有细微差异。应对：先锁定 Anthropic，其他提供商留位
4. **Tape 双写一致性** — 文件写成功但 SQLite 写失败。应对：rebuild_index 修复机制
